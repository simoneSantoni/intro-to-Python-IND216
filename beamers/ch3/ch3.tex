% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
% =========================================================================
%\documentclass[notes, aspectratio=1610]{beamer}
\documentclass[aspectratio=1610]{beamer}

% ========================= Theme =========================================
\usetheme{CambridgeUS}
\usecolortheme{default}

% ========================= Essential packages ============================
\usepackage{hyperref}

% ========================= Essential packages ============================
%\usepackage{pgfpages}
%\setbeameroption{show notes on second screen}

% ========================= Plotting ======================================
\usepackage{calc}
\usepackage{tikz}
\usetikzlibrary{arrows,
                arrows.meta,
                calc,
		chains,
                quotes,
                positioning,
		shapes,
                shapes.geometric}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{pgfplots}
\pgfplotsset{width=7cm,compat=1.17}

%% ============================== Tabular =================================
\usepackage{booktabs}
\usepackage{tabularx,ragged2e}
\usepackage{array}
\usepackage{multirow}
\usepackage{siunitx}
  \sisetup{detect-all}
\usepackage{adjustbox}
\usepackage{rotating}
\usepackage{threeparttable}
\usepackage[justification=centering]{caption}

%% ========================== Coding snippets =============================
% Default fixed font does not support bold face
\usepackage{minted}
\usemintedstyle{vs}

% ========================= Infor on authors ==============================
\title{Intro to Python --- SMM692}
\subtitle{Python Objects}
\author{Simone Santoni}
\institute{Bayes Business School}
\date{MSc Pre-Course Series}

% ============================ Colors =====================================
\definecolor{base_c}{rgb}{0.6,0,0}
\definecolor{comp_c}{rgb}{0.09803921568627451, 0.6901960784313725, 0.7529411764705882}
\definecolor{tri_1}{rgb}{0.09803921568627451, 0.7686274509803922, 0.19215686274509805}
\definecolor{tri_2}{rgb}{0.19215686274509805, 0.09803921568627451, 0.7686274509803922}

% ========================= TOC  ==========================================
\AtBeginSubsection[]
{
    \begin{frame}
        \frametitle{Outline}
        \tableofcontents[currentsection,currentsubsection]
    \end{frame}
}

% ========================= Document  ====================================
\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}{Outline}
	\tableofcontents
\end{frame}

% ------------------------- Background -----------------------------------

\section{The Chapter in a Nutshell}

\begin{frame}
    \frametitle{Scope}
    In Chapter 3, the attention revolves around the following topics:

    \begin{itemize}
        \item The concept of Python object 
        \item The types of Python objects
        \item The characteristics of each Python object
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Why Shall I Learn About Python Objects?}
    \begin{itemize}
    	\item Built-in objects make coding efficient and easy
        \begin{itemize}
            \item  For example, using the \href{https://docs.python.org/3/tutorial/introduction.html\#strings}{string} object, we can represent and manipulate a piece of text --- e.g., a newspaper article --- without loading any \href{https://docs.python.org/3/tutorial/modules.html}{module}
        \end{itemize}
           	\item Built-in objects are flexible
            \begin{itemize}
                \item For example, we can deploy built-in objects to create a \href{https://docs.python.org/3/tutorial/classes.html}{class}
            \end{itemize}
    	\item Built-in objects have been created and refined over time by a large community of expert developers. Hence, they are  often  more  efficient  than  ad-hoc objects (unless the creator of the ad-hoc object knows her business!)
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Learning Goals}
    At the end of the chapter, you will be able to evaluate the various types of Python objects regarding:
    \begin{itemize}
        \item Key features
        \item Use cases/roles
        \item Available methods
    \end{itemize}
\end{frame}

\section{Python Objects Fundamentals}

\note{This is a note?!}

\begin{frame}
    \frametitle{What is a Python Object?}
    
    In essence, Python objects are pieces of data. Mark Lutz, the author of the popular book \href{https://www.google.co.uk/books/edition/Learning_Python/4pgQfXQvekcC?hl=en&gbpv=0}{\textcolor{blue}{Learning Python}}, points out

    \vspace{2em}
    
    \begin{quote}
    \textit{``... in Python, we do things with stuff. ``Things'' take the form of operations like addition and concatenation, and ``stuff'' refers to the objects on which we perform those operations''}
    \end{quote}

\end{frame}

\begin{frame}
    \frametitle{What Are the Main Families of Python Objects?}
    In Python, there are two families of objects:
    
    \begin{itemize}
        \item Built-in objects provided by the Python language itself
        \item Ad-hoc objects --- called \href{https://docs.python.org/3/tutorial/classes.html}{classes} --- we can create to accomplish specific goals
    \end{itemize}
    
    \end{frame}

\begin{frame}
    \frametitle{What Are the Main Types of Built-In Python Objects?}
    \begin{itemize}
        \item Strings
        \item Numbers
        \item Data containers
        \begin{itemize} 
            \item Lists 
            \item Dictionaries
            \item Tuples 
            \item Sets 
        \end{itemize}
        \item Files 
        \item Python statements, syntax, and control flow
        \item Iterators 
    \end{itemize}
\end{frame}

\section{Built-In Python Object Types }
\subsection{Numbers \& Strings}

\begin{frame}[fragile]{Integers and Floating Points}
	\begin{columns}[t]
		\begin{column}{0.45\textwidth}		
            
            The most common number types are integers and floating-point numbers:
            \begin{itemize}
                \item Integers are whole numbers such as 0, 4, or -12
                \item Floating-point numbers represent real numbers such as 0.5, 3.1415, or -1.6e-19
                \begin{itemize}
                    \item However, floating points in Python do not have --- in general
                    --- the same value as the real number they represent
                    \item It is worth noticing that any single number with a period `.'
                    is considered a floating point in Python 
                \end{itemize}
            \end{itemize}
	
    \end{column}
    
    \begin{column}{0.45\textwidth}
        
        Snippet 4.1 --- doing `stuff' with numbers
        \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}
# integer addition
>>> 1 + 1
2

# floating-point multiplication
>>> 10 * 0.5
5.0

# 3 to the power 100
>>> 3 ** 100
515377520732011331036461129765621272702107522001

        \end{minted}
        \rule{\textwidth}{1pt}
		
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
    \frametitle{Number Type Objects in Python}
    \begin{table}[!htbp]
    	\centering
    	\caption*{Number Type Objects in Python}
    	\label{tab:number_types_in_python}
    	\begin{tabular}{ll}
    		\toprule \toprule
    		Literal & Interpretation\\
    		\midrule
    		 1234, -24, 0, 99999999999999 & Integers (unlimited size)\\
    		 1.23, 1., 3.14e-10, 4E210, 4.0e+210 & Floating-point numbers \\
    		 0o177, 0x9ff, 0b101010 & Octal, hex, and binary literals in 3.X \\
    		 0177, 0o177, 0x9ff, 0b101010 & Octal, octal, hex, and binary literals in 2.X \\
    		 3+4j, 3.0+4.0j, 3J & Complex number literals \\
    		 set(`spam'), \{1, 2, 3, 4\} & Sets: 2.X and 3.X construction forms\\ Decimal(`1.0'), Fraction(1, 3) & Decimal and fraction extension types\\
    		 bool(X), True, False & Boolean type and constants\\
    		 \bottomrule
    	\end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]
    \frametitle{String Type Fundamentals}
    \begin{columns}
        \begin{column}{0.35\textwidth}
            \quad \textbf{What:} A Python string is a positionally ordered collection of other
            objects. Strictly speaking, strings are \textit{immutable
            sequences} of one-character strings; other, more general sequence
            types include lists and tuples, covered later.

            \vspace{1em}
            
            \quad \textbf{How and why:} Strings are used to record words, contents of text files loaded into memory, Internet addresses, Python source code, and so on.
        \end{column}
        \begin{column}{0.60\textwidth}
        \normalsize Snippet 4.6 --- Python strings as sequences
        \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}
           
# the string
>>> S = "Python 3.X"
# check the length of S
>>> len(S)
6
# access the first unitary string in the sequence behind S 	
>>> S[0]
"P"
# access the last unitary string in the sequence behind S
>>> S[len(S)-1]
"X"
# or, equivalently
>>> S[-1]
"X"
# access the unitary strings between the i-th and j-th positions in the 
# sequence behind S
>>> S[2:5]
"tho"
        \end{minted}
        \rule{\textwidth}{1pt}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
    \frametitle{Sting Literals and Operators}
    \begin{table}[!htbp]
    	\centering
    	\begin{tabular}{ll}
    		\toprule \toprule
    		Literal/operation & Interpretation \\
    		\midrule
    		\texttt{S = ""} &  Empty string \\
    		\texttt{S = `'} &   Single quotes, same as double quotes \\
    		\texttt{S = "spam's"} & Single quote as a string \\
    		\texttt{S = `spam$\setminus$'s'} & Escape symbol \\
    		\texttt{length(S)} & Length \\
    		\texttt{S[i]} & Index \\
    		\texttt{S[i:j]} & Slice \\
    		\texttt{S1 + S2} & Concatenate \\
    		\texttt{S * 3} & Repeat S $n$ times (e.g., three times)\\
    		\texttt{"text".join(strlist)} & Join multiple strings on a character (e.g., ``text'')\\
    		\texttt{"\{\}".format()} & String formatting expression \\ 
   		\bottomrule
    	\end{tabular}
    \end{table}
\end{frame}

\begin{frame}
    \frametitle{String Literals and Operators (cont'd)}	
    \begin{table}[!htbp]
        \centering
        \begin{tabular}{ll}
    		\toprule \toprule
    		Literal/operation & Interpretation \\
    		\midrule
     		\texttt{S.strip()} & Remove white spaces \\
    		\texttt{S.replace("pa", "xx")} & Replacement \\
    		\texttt{S.split(",")} & Split on a character (e.g., ``,'') \\
    		\texttt{S.lower()} & Case conversion --- to lower case \\
    		\texttt{S.upper()} & Case conversion --- to upper case \\
            \texttt{S.find("text")} & Search substring (e.g., "text") \\
    		\texttt{S.isdigit()} & Test if the string is a digit \\
    		\texttt{S.endswith("spam")} & End test \\
            \texttt{S.startswith("spam")} & Start test \\
    		\texttt{S = """...multiline..."""} & Triple-quoted block strings \\
    		\bottomrule
    	\end{tabular}
    \end{table}
\end{frame}

\subsection{Data Containers}

\begin{frame}[fragile]
    \frametitle{List Type Fundamentals}
\begin{columns}
    \begin{column}{0.35\textwidth}
    \quad \textbf{What:} A Python \href{https://docs.python.org/3/tutorial/datastructures.html}{\texttt{list}} is an \emph{ordered}, \emph{mutable} array of objects. A list is constructed by specifying the objects, separated by commas, between square brackets, \texttt{[]}
    
    \vspace{1em}

    \quad \textbf{How and why:} Lists are just places to collect other objects --- being numbers, strings, or even other lists --- so you can treat them as groups.
    \end{column}
    \begin{column}{0.6\textwidth}
    \normalsize Snippet 4.11 --- list indexing and slicing 
    \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}          
# the list
>>> L = [4, ["abc", 8.98]]
# get the first item of L
>>> L[0]
4
# get the second element of L
>>> L[1]
["abc", 8.98]
# get the first item of L's second item
>>> L[1][0]
"abc"
        \end{minted}
    \rule{\textwidth}{1pt}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
    \frametitle{Popular List Methods}
    \begin{table}[!htbp]
    	\centering
        \small
    	\begin{tabular}{lp{10cm}}
    		\toprule \toprule
    		Method & Synopsis \\
    		\midrule 
    		\texttt{L.append(X)} & Append an item to an existing list\\
    		\texttt{L.insert(i, X)} & Append an item to an existing list in position $i$ \\
    		\texttt{L.extend([X0, X1, X2])} & Extend an existing list with the items from another list\\
    		\texttt{L.index(X)} & Get the index of the first instance of the argument in an existing list\\
    		\texttt{L.count(X)} & Get the cardinality of an item in an existing list\\
    		\texttt{L.sort()} & Sort the items in an existing list\\
    		\texttt{L.reverse()} & Reverse the order of the items in an existing list\\
    		\texttt{L.copy()} & Get a copy of an existing list\\
    		\texttt{L.pop(i)} & Remove the item at the given position in the list, and return it\\
    		\texttt{L.remove(X)} & Remove the first instance of an item in an existing list\\
    		\texttt{L.clear()} & Remove all items in an existing list\\
    		\bottomrule 
    	\end{tabular}
    \end{table}
\end{frame}

\begin{frame}[fragile]{Sample List Methods in Action}
    Snippet 4.13 --- methods for expanding an existing list
    \rule{\textwidth}{1pt}
    \scriptsize
    \begin{minted}{python}
# create two lists 
>>> L1 = ["Leonard", "Penny", "Sheldon"]
>>> L2 = ["Howard", "Raj", "Amy", "Bernadette"]
# expand an existing list with .append()
>>> L2.append("Priya") 
>>> print(L2)
["Howard", "Raj", "Amy", "Bernadette", "Priya"]
# concatenate L1 and L2 with .extend()
>>> L1.extend(L2)
>>> print(L1)
["Leonard", "Penny", "Sheldon", "Howard", "Raj", "Amy", "Bernadette", "Priya"]
    \end{minted}
    \rule{\textwidth}{1pt}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Dictionary Type Fundamentals}
\begin{columns}
    \begin{column}{0.35\textwidth}
    \quad \textbf{What:} 
    If you think of lists as ordered collections of objects, you can think of dictionaries as unordered collections; the chief distinction is that in dictionaries, items are stored and fetched by \emph{key} instead of by \emph{positional offset}.
    
    \vspace{1em}

    \quad \textbf{How and why:} 
    Dictionaries take the place of records, search tables, and any other sort of aggregation where item names are more meaningful than item positions.
    \end{column}
    \begin{column}{0.6\textwidth}
    \normalsize Snippet 4.15 --- initializing a new dictionary object
    \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}          
# method 1 
>>> D = {
    "Captain Marvel": 3,
    "Living Tribunal": 2,
    "One-Above-All": 1
    }
# method 2
>>> CHARACTERS = [
    "Captain Marvel",
    "Living Tribunal",
    "One-Above-All"
    ]
>>> RANK = [3, 2, 1]
>>> D = dict(zip(CHARACTERS, RANK)) 
>>> print(D)
{"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}
        \end{minted}
    \rule{\textwidth}{1pt}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
    \frametitle{Popular Dictionary Methods}
    \begin{table}[!htbp]
    	\centering
        \small
    	\begin{tabular}{lp{10cm}}
    		\toprule \toprule
    		Method & Synopsis \\
    		\midrule 
    		\texttt{D.keys()} & Get a list of all keys in a dictionary\\
    		\texttt{D.values()} & Get a list of all values in a dictionary\\
    		\texttt{D.items()} & Get a list of all key-value pairs in a dictionary\\
    		\texttt{D.get(key, default)} & Get the value of a key in a dictionary, or a default value if the key is not present\\
    		\texttt{D.update(D2)} & Update a dictionary with the key-value pairs from another dictionary\\
    		\texttt{D.copy()} & Get a copy of a dictionary\\
    		\texttt{D.clear()} & Remove all key-value pairs from a dictionary\\
    		\bottomrule 
    	\end{tabular}
    \end{table}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Sample Dictionary Methods in Action}
    Snippet 4.18 --- accessing the informaton included in a dictionary
    \rule{\textwidth}{1pt}
    \scriptsize
    \begin{minted}{python}
# the dictionary 
>>> D = {"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}
# let us change the power rank for Captain Marvel
>>> D["Captain Marvel"] = 12
>>> print(D)
{"Captain Marvel": 12, "Living Tribunal": 2, "One-Above-All": 1}
# let us eliminate the character Living Tribunal 
>>> del D["Living Tribunal"]
>>> print(D)
{"Captain Marvel": 12, "One-Above-All": 1}
# let us add a further character 
>>> D["Wanda Maximoff"] = 4
>>> print(D)
{"Captain Marvel": 12, "One-Above-All": 1, "Wanda Maximoff": 4}
    \end{minted}
    \rule{\textwidth}{1pt}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Tuple Type Fundamentals}
    \begin{columns}
    \begin{column}{0.45\textwidth}
    \quad \textbf{What:} 
    Tuples are sequences of immutable Python objects. They are similar to lists, but they are immutable. Tuples are created by enclosing a comma-separated list of values in parentheses.
    \vspace{1em}
    \quad \textbf{How and why:}
    Tuples are useful for storing data that is not to be changed, such as the coordinates of a point in a two-dimensional space. In general, we use tuples any time information integrity is a concern --- in other words when we want to ensure the information included in an object will not change because of another reference in our program.
    \end{column}
    \begin{column}{0.5\textwidth}
    \normalsize Snippet 4.19 --- creating and accessing a table 
    \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}          
# the tuple
>>> T = ("Captain Marvel", 3)
# access a tuple element
>>> T[0]
"Captain Marvel"
# access a tuple element
>>> T[1]
3
        \end{minted}
    \rule{\textwidth}{1pt}
    \end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Set Type Fundamentals}
\begin{columns}
    \begin{column}{0.45\textwidth}
    \quad \textbf{What:} 
    A \href{https://docs.python.org/3/tutorial/datastructures.html\#sets}{\texttt{set}} is an \emph{unordered} collection of \emph{unique} and \emph{immutable} objects.
    \vspace{1em}
    
    \quad \textbf{How and why:}
    Sets made this way support common mathematical set operations. Hence, they have a variety of applications, especially in numeric and database-focused work.
    \end{column}
    \begin{column}{0.45\textwidth}
        Snippet 4.23 --- set operations
    \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}          
# create two sets 
>>> X = set(["a", "b", "c"])
>>> Y = set(["c", "d", "e"])
# set difference 
>>> X - X
set()
>>> X - Y
{"a", "b"}
# union
>>> X | Y
{"a", "b", "c", "d", "e"}
# intersection
>>> X & Y
{"c"}
# superset
>>> X > Y
False
# subset
>>> X < Y
False
        \end{minted}
    \rule{\textwidth}{1pt}
    \end{column}
\end{columns}
\end{frame}

\subsection{Files}

\begin{frame}[fragile]
    \frametitle{Reading and Writing Data through Pipes}
\begin{columns}
    \begin{column}{0.30\textwidth}
    \quad \textbf{What:} 
    Your Python program may read data from a file stored in your machine and/or write the outcome of your analysis to a file. 
    \vspace{1em}

    \quad \textbf{How and why:}
    You open a pipe to a file using the built-in function \href{https://docs.python.org/3/library/functions.html\#open}{\texttt{open}}. The output of the function is a \texttt{file} object.
    \end{column}
    \begin{column}{0.60\textwidth}
        Snippet 4.24 --- data input with open
    \rule{\textwidth}{1pt}
        \scriptsize
        \begin{minted}{python}          
# create a pipe to a file
>>> file = open(file="my_file.txt", mode="r")

# calling "file" yields the attributes of the file object
>>> file
<_io.TextIOWrapper name="my_file.txt" mode="r" encoding="UTF-8">

# let us source the data
>>> data = file.read()
>>> print(data)
Hi there

# close the pipe
>>> file.close()
        \end{minted}
    \rule{\textwidth}{1pt}
    \end{column}
\end{columns}
\end{frame}


\begin{frame}
    \frametitle{File Methods}
    \begin{table}[!htbp]
    	\centering
        \small
    	\begin{tabular}{ll}
    		\toprule \toprule
    		Method                     & Description                                                                          \\
    		\midrule
    		\texttt{file.close()     } & Closes the file                                                                      \\
    		\texttt{file.detach()    } & Returns the separated raw stream from the buffer                                     \\
    		\texttt{file.fileno()    } & Returns a number that represents the stream as per the OS' perspective               \\
    		\texttt{file.flush()     } & Flushes the internal buffer                                                          \\
    		\texttt{file.isatty()    } & Returns whether the file stream is interactive or not                                \\
    		\texttt{file.read()      } & Returns the file content                                                             \\
    		\texttt{file.readable()  } & Returns whether the file stream can be read or not                                   \\
    		\texttt{file.readline()  } & Returns one line from the file                                                       \\
    		\texttt{file.readlines() } & Returns a list of lines from the file                                                \\
    		\texttt{file.seek()      } & Change the file position                                                             \\
    		\texttt{file.seekable()  } & Returns whether the file allows us to change the file position                       \\
    		\texttt{file.tell()      } & Returns the current file position                                                    \\
    		\texttt{file.truncate()  } & Resizes the file to a specified size                                                 \\
    		\texttt{file.writable()  } & Returns whether the file can be written to or not                                    \\
    		\texttt{file.write()     } & Writes the specified string to the file                                              \\
    		\texttt{file.writelines()} & Writes a list of strings to the file                                                 \\
    		\bottomrule% \\[-1.8ex]
    		%\multicolumn{2}{l}{Notes: \texttt{file} is a fictionary object used to illustrate the usage of the file methods.} \\
    	\end{tabular}
    \end{table}
\end{frame}

\subsection{Python Statements, Syntax, and Control Flow}

\begin{frame}
    \frametitle{Python Statement Fundamentals}
    \centering
    \Large In simple terms, Python statements are \textit{``the things you write to tell Python what your program should do''}. (Lutz, 2013)
\end{frame}

\begin{frame}[fragile]
    \frametitle{Control Flow}
        \begin{columns}
            \begin{column}{0.35\textwidth}
            \quad \textbf{What:} 
            Many Python statements we write are compound statements: there is one statement nested inside another. The outer statement is called the `if' statement, and the inner statement is called the `then' statement.
            \vspace{1em}
        
            \quad \textbf{How and why:}
            The `if' statement determines whether to execute the `then' statement. Specifically, the `then' statement is executed insofar as the `if' statement evaluates to `True.'
            \end{column}
            \begin{column}{0.55\textwidth}
            Snippet 4.28 --- an example of control flow
            \rule{\textwidth}{1pt}
                \scriptsize
                \begin{minted}{python} 
# a set with a customer's past purchases
>>> S = set(["a", "x", "u"])

# a rule-based product recommender 
>>> if "x" in S:
...     print(
...          "Customers who bought x also bought Air" \ 
...          "Jordan 7 Retro Miro"
...          )
... else:
...     pass
Customers who bought x also bought Air Jordan 7 Retro Miro
               \end{minted}
           \rule{\textwidth}{1pt}
           \end{column}
    \end{columns}
\end{frame}

\subsection{Iterators }

\begin{frame}[fragile]
    \frametitle{While and For Loops}
        \begin{columns}
            \begin{column}{0.35\textwidth}
            \quad \textbf{What:} 
            Oftentimes, we write Python statements that repeat the same task --- i,e. they loop a certain number of times or over multiple items.

            \vspace{1em}
        
            \quad \textbf{How and why:}
            The \href{https://docs.python.org/3/reference/compound_stmts.html\#while}{\texttt{while}} statement provides a way to code general loops. The \href{https://docs.python.org/3/reference/compound_stmts.html\#for}{\texttt{for}} statement is designed for stepping through the items in a sequence or other iterable object and running a block of code for each.
            \end{column}
            \begin{column}{0.55\textwidth}
            Snippets 4.31/32 --- while and for loop examples
            \rule{\textwidth}{1pt}
                \scriptsize
                \begin{minted}{python} 
# loop until reaching a numeric threshold
>>> i = 0
>>> while i <= 3:
...     print(i)
...     i = i + 1
0
1
2
3
# run a mathematical operation on a list of items and 
# append the outcome to a second list 
>>> input = [2, 8, 1]
>>> output = []
>>> for item in input:
...    output.append(item + 1)
>>> print(output)
[3, 9, 2]
               \end{minted}
           \rule{\textwidth}{1pt}
           \end{column}
    \end{columns}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Iterations and Comprhensions}
        \begin{columns}
            \begin{column}{0.35\textwidth}
            \quad \textbf{What:} 
            As we know from the previous section, \texttt{while} and \texttt{for} loops can handle most repetitive tasks programs need to perform.  One of the most prominent tools is \href{https://docs.python.org/3/tutorial/datastructures.html}{\texttt{list comprehension}}.

            \vspace{1em}
        
            \quad \textbf{How and why:}
            List comprehnsions make loops \emph{easier to write/read} and \emph{more efficient}. In practice, we include a Python statement containing a for loop among brackets.
            \end{column}
            \begin{column}{0.55\textwidth}
            Snippets 4.38 --- nested for loops Vs. list comprhension
            \rule{\textwidth}{1pt}
                \scriptsize
                \begin{minted}{python} 
# the for loop way
# --+ create an empty list
L = []
# --+ create a for loop appending the square of some items
>>> for i in range(3):
...    L.append(i ** 2)
# --+ print the list
>>> print(L)
[0, 1, 4]

# the list comprehension way
>>> L = [i ** 2 for i in range(3)]
>>> print(L)
[0, 1, 4]
               \end{minted}
           \rule{\textwidth}{1pt}
           \end{column}
    \end{columns}
\end{frame}

\section{Wrap-Up}

\begin{frame}
    \frametitle{At the End of the Chapter, You Will Be Able to...}
\end{frame}

\end{document}