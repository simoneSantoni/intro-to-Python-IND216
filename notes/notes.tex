% !TeX document-id = {623e3a94-4cb1-4158-99bf-bcee8b7d3f42}
%% =========================== Document class =============================
\documentclass[a4paper,11pt]{book}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]

%% ========================= Essential packages ===========================
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
%\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{lineno}
\usepackage{amsmath}
\usepackage{endnotes}
\let\footnote=\endnote
\usepackage[titletoc]{appendix}
\numberwithin{figure}{chapter}
\numberwithin{table}{chapter}

%% ========================== Coding snippets =============================
\usepackage[newfloat]{minted}
\usepackage[many]{tcolorbox}
\definecolor{Gray}{gray}{0.9}
\newcommand{\txtmint}[1]{\mintinline[fontsize=\scriptsize, bgcolor=Gray]{text}{#1}}
\tcbuselibrary{minted,skins,breakable}
\newtcblisting{pythoncode}[2][]{
  listing engine=minted,
  breakable,
  colback=green,
  colframe=black!70,
  listing only,
  minted style=vs,
  minted language=python,
  minted options={numbersep=3mm,texcl=true,#1},
  left=5mm,enhanced,
  overlay={\begin{tcbclipinterior}\fill[black!25] (frame.south west)
            rectangle ([xshift=5mm]frame.north west);\end{tcbclipinterior}},
            #2,
}

%% ============================== Tabular =================================
\usepackage{booktabs}
\usepackage{tabularx,ragged2e}
\usepackage{array}
\usepackage{multirow}
\usepackage{siunitx}
  \sisetup{detect-all}
\usepackage{adjustbox}
\usepackage{rotating}
\usepackage{threeparttable}
\usepackage[justification=centering]{caption}
\captionsetup[table]{labelfont=sc, labelsep=newline}
%\renewcommand{\figurename}{\itshape Fig.}
%\renewcommand{\thetable}{\Roman{table}}

%% ====================== To implement the Cornell ========================
\usepackage{paracol} % added <<<<<<<<<<<<<<<<<<<<<
\makeatletter
\newbox\mybox
\def\pcol@makenormalcol{%
  \ifvoid\footins 
  \else
\global\setbox\mybox\box\footins
   \fi
\setbox\@outputbox\box\@holdpg
  \let\@elt\relax
  \xdef\@freelist{\@freelist\@midlist}%
  \global\let\@midlist\@empty
  \@combinefloats}

\makeatother

%% ============================ Plots ====================================
\usepackage{pgf}


%% =========================== Color options ==============================
% custom colors
\definecolor{base_c}{rgb}{0.6,0,0}
\definecolor{comp_c}{rgb}{0.09803921568627451, 0.6901960784313725, 0.7529411764705882}
\definecolor{tri_1}{rgb}{0.09803921568627451, 0.7686274509803922, 0.19215686274509805}
\definecolor{tri_2}{rgb}{0.19215686274509805, 0.09803921568627451, 0.7686274509803922}

%% =============================== Links ==================================
\usepackage[
colorlinks=true,
allcolors=tri_2,
%citecolor=CadetBlue,
%urlcolor=CadetBlue
]{hyperref}%

% =========================== Utilities ===================================
\usepackage{lipsum}% generate filler text

% ========================= Cornell Notes stuff ============================
% question
\newcommand{\question}[1]{% Ask the question
    \begin{tcolorbox}[colback=comp_c!10,colframe=comp_c,sidebyside align=top,width=\linewidth,before skip=1ex]
        #1
    \end{tcolorbox}
    \switchcolumn% now write in the right column
}

% note
\newcommand{\note}[1]{% Add as many notes as you like
    \begin{tcolorbox}[colback=white!0,colframe=white!10,width=\linewidth,before skip=1ex]
        #1
    \end{tcolorbox}
}

% summary
\newcommand{\summary}[2][]{%
\begin{minipage}[b]{\textwidth}
    \vspace*{\baselineskip}
    \begin{tcolorbox}[colframe=tri_2!75,fonttitle=\large\bfseries\sffamily,
        after skip = \baselineskip,
        title=Summary]
        #2
    \end{tcolorbox}
\end{minipage}
#1}

% proportions
\setcolumnwidth{0.4\textwidth/20pt,0.60\textwidth}% column separation =20pt
\setlength{\columnseprule}{2pt} % column width
\colseprulecolor{gray}

% title
\title{%
        \begin{tcolorbox}[before skip = \baselineskip, after skip =-\baselineskip]
            \centering\Huge\sffamily SMM692\\ Introduction to Programming in Python 
        \end{tcolorbox}
}

% ============================ Document attrs ==============================
\date{}
\parindent=0pt


% ========================== Document contents ============================= 

\begin{document}
    
\maketitle  

\clearpage

\tableofcontents

\listoffigures

\listoftables

\clearpage

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

$\ldots$

\chapter{Organization of the Module}

\hline

\vspace{1em}

\hline

\vspace{1em}

$\ldots$

\chapter{Getting Started with Python}

\hline

\vspace{1em}

\hline

\vspace{1em}

\section{Installing Python}

$\ldots$

\section{How Python Runs Programs}

$\ldots$

\section{How We Run Python Programs}

$\ldots$

\section{Managing Python Environments}

$\ldots$

\chapter{Python Language Fundamentals}

\hline

\vspace{1em}

\hline

\vspace{1em}

\section{Variables}

$\ldots$

\section{Objects}

$\ldots$

\section{References}

$\ldots$

\chapter{Python Objects}

\hline

\vspace{1em}

\hline

\vspace{1em}

In this chapter, we pursue the following learning objectives:

\begin{itemize}
	\item ....
\end{itemize}

\begin{paracol}{2}
    \question{\raggedright What is a Python object?} 
    \note{In essence, Python objects are pieces of data. Mark Lutz, the author of the popular book \href{https://www.google.co.uk/books/edition/Learning_Python/4pgQfXQvekcC?hl=en&gbpv=0}{Learning Python}\footnote{Lutz, Mark. \textit{Learning Python: Powerful object-oriented programming.} O'Reilly Media, Inc., 2013.}, points out \quote{\textit{in Python we do things with stuff. ``Things'' take the form of operations like addition and concatenation, and ``stuff'' refers to the objects on which we perform those operations}}. 
    }
\end{paracol}

\begin{paracol}{2}
    \question{\raggedright Built-in and ad-hoc objects}
    \note{In Python, there are two families of objects: built-in objects provided by the Python language itself and ad-hoc objects --- called \href{https://docs.python.org/3/tutorial/classes.html}{classes} --- we can create to accomplish specific goals.}
\end{paracol}

\begin{paracol}{2}
    \question{\raggedright Why do built-in Python objects matter?} 
    \note{
    Typically, we do not need to create ad-hoc objects. Python provides us with diverse built-in objects that make our job easier:
    \begin{itemize}
    	\item built-in objects make coding efficient and easy. For example, using the \href{https://docs.python.org/3/tutorial/introduction.html#strings}{string} object, we can represent and manipulate a piece of text --- e.g., a newspaper article --- without loading any \href{https://docs.python.org/3/tutorial/modules.html}{module}
    	\item built-in objects are flexible. For example, we can deploy built-in objects to create a \href{https://docs.python.org/3/tutorial/classes.html}{class}
    	\item built-in objects have been created and refined over time by a large community of expert developers. Hence, they are  often  more  efficient  than  ad-hoc objects (unless the creator of the ad-hoc object really knows her business!)
    \end{itemize}}
\end{paracol}
\clearpage

\begin{paracol}{2}
    \question{\raggedright The core built-in Python objects} 
	\note{Table \ref{tab:built_in_objects} illustrates the types of built-in Python objects. For example, \href{https://docs.python.org/3/tutorial/introduction.html#numbers}{Numbers} and \href{https://docs.python.org/3/tutorial/introduction.html#strings}{strings} objects are used to represent numeric and textual data respectively. \href{https://docs.python.org/3/tutorial/introduction.html#lists}{Lists} and \href{https://docs.python.org/3/tutorial/datastructures.html#dictionaries}{dictionaries} are --- likely as not --- the two most popular \href{https://docs.python.org/3/tutorial/datastructures.html}{data structures} in Python. Lists are ordered collections of other objects such (any type!!). Dictionaries are pairs of keys (e.g., a product identifier) and objects (e.g., the price of the product). No worries: we will go through each built-in type in the following sections of this document. Caveat: in the interest of logical coherence, the various built-in types will not be presented in the order adopted Table \ref{tab:built_in_objects}.} 
\end{paracol}

\begin{table}[!htbp]
\centering
\caption{Built-In Objects in Python}
\label{tab:built_in_objects}
\begin{tabular}{@{}ll@{}}
\toprule \toprule
Object type          & Example literals/creation                                            \\ \midrule
Numbers              & 1234, 3.1415, 3+4j, 0b111, Decimal(), Fraction()                     \\
Strings              & `spam', ``Bob's'', b`a\textbackslash{}x01c', u`sp\textbackslash{}xc4m' \\
Lists                & {[}1, {[}2, `three'{]}, 4.5{]}, list(range(10))                      \\
Dictionaries         & \{`food': `spam', `taste': `yum'\}, dict(hours=10)                   \\
Tuples               & (1, `spam', 4, `U'), tuple(`spam'), namedtuple                       \\
Files                & open(`eggs.txt'), open(r`C:\textbackslash{}ham.bin', `wb')           \\
Sets                 & set(`abc'), \{`a', `b', `c'\}                                        \\
Other core types     & Booleans, types, None                                                \\
Program unit types   & Functions, modules, classes                                          \\
Implementation types & Compiled code, stack tracebacks                                      \\ \bottomrule
\end{tabular}
\end{table}

\section{Number Type Fundamentals}

\begin{paracol}{2}
    \question{\raggedright Types of `number' objects}
	\note{Snippet 4.1, ``Doing stuff with numbers,'' highlights the two most popular \href{https://docs.python.org/3/tutorial/introduction.html#numbers}{`number'} instances in Python: integers and floating-point numbers. Integers are whole numbers such as 0, 4, or -12. Floating-point numbers are the representation of real numbers such as 0.5, 3.1415, or -1.6e-19. However, floating points in Python do not have --- in general --- the same value as the real number they represent.\footnote{Floating numbers are stored in binaries with an assigned level of precision that is typically equivalent to 15 or 16 decimals.} It is worth noticing that any single number with a period `.' is considered a floating point in Python. Also, Snippet 4.1 shows that the multiplication of an integer by a floating point yields a floating point. That happens because Python first converts operands up to the type of the most complicated operand.} %
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.1 --- doing `stuff' with numbers}
# integer addition
>>> 1 + 1
2

# floating-point multiplication
>>> 10 * 0.5
5.0

# 3 to the power 100
>>> 3 ** 100
515377520732011331036461129765621272702107522001

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Besides integers and floating points}
    \note{Besides integers and floating points numbers, Python includes fixed-precision, rational numbers, Booleans, and sets instances --- see Table \ref{tab:number_types_in_python}.}
\end{paracol}

\begin{table}[!htbp]
	\centering
	\caption{Number Type Objects in Python}
	\label{tab:number_types_in_python}
	\begin{tabular}{ll}
		\toprule \toprule
		Literal & Interpretation\\
		\midrule
		 1234, -24, 0, 99999999999999 & Integers (unlimited size)\\
		 1.23, 1., 3.14e-10, 4E210, 4.0e+210 & Floating-point numbers \\
		 0o177, 0x9ff, 0b101010 & Octal, hex, and binary literals in 3.X \\
		 0177, 0o177, 0x9ff, 0b101010 & Octal, octal, hex, and binary literals in 2.X \\
		 3+4j, 3.0+4.0j, 3J & Complex number literals \\
		 set(`spam'), \{1, 2, 3, 4\} & Sets: 2.X and 3.X construction forms\\ Decimal(`1.0'), Fraction(1, 3) & Decimal and fraction extension types\\
		 bool(X), True, False & Boolean type and constants\\
		 \bottomrule
	\end{tabular}
\end{table}

\begin{paracol}{2}
	\question{\raggedright Basic arithmetic operations in Python}
	\note{Numbers in Python support the usual mathematical operations:
		\begin{itemize}
			\item `+' $\rigtharrow$ addition
			\item `-' $\rightarrow$ subtraction
			\item `*' $\rightarrow$ multiplication
			\item `/' $\rightarrow$ floating point division
			\item `//' $\rightarrow$ integer division
			\item `\%' $\rightarrow$ modulus (remainder)
			\item `**' $\rightarrow$ exponentiation
		\end{itemize}
		 To use these operations, it is sufficient to launch a  Python or IPython session without any modules loaded (see Snippet 4.1).}
\end{paracol}

\begin{paracol}{2}
    \question{\raggedright Advanced mathematical operations}
    \note{Besides the mathematical operations shown above, there are many \href{https://docs.python.org/3/library/numeric.html}{modules shipped with Python} that carry out advanced/specific numerical analysis. For example, the \href{https://docs.python.org/3/library/math.html}{\texttt{math}} module provides access to the mathematical functions defined by the \href{https://en.wikipedia.org/wiki/C_standard_library}{C standard}.\footnote{As per the documentation of the Python programming language, \href{https://docs.python.org/3/library/math.html}{\texttt{math}} cannot be used with complex numbers.} Table \ref{tab:math_module_functions} reports a sample of these functions. To use them \href{https://docs.python.org/3/library/math.html}{\texttt{math}}, we have to import the module as shown in Snippet 4.2. Another popular module shipped with Python is \href{https://docs.python.org/3/library/random.html}{\texttt{random}}, implementing pseudo-random number generators for various distributions (see the lower section of Example 2).}
\end{paracol}

\begin{table}[!htbp]
	\centering
	\caption{A Sample of Functions Provided by the \href{https://docs.python.org/3/library/math.html}{\texttt{math}} Module}
	\label{tab:math_module_functions}
	\begin{tabular}{ll}
		\toprule \toprule
		Function name &  Expression \\
		\midrule
		\texttt{math.sqrt(x)} & $\sqrt{x}$ \\
		\texttt{math.exp(x)} & $e^{x}$ \\
		\texttt{math.log(x)} & $ln{x}$ \\
		\texttt{math.log(x, b)} & $log_{b}(x)$ \\
		\texttt{math.log10(x)} & $log_{10}(x)$ \\
		\texttt{math.sin(x)} & $sin(x)$ \\
		\texttt{math.cos(x)} & $cos(x)$ \\
		\texttt{math.tan(x)} & $tan(x)$ \\
		\texttt{math.asin(x)} & $arcsin(x)$ \\
		\texttt{math.acos(x)} & $arccos(x)$ \\
		\texttt{math.atan(x)} & $arctan(x)$ \\
		\texttt{math.sinh(x)} & $sinh(x)$ \\
		\texttt{math.cosh(x)} & $cosh(x)$ \\
		\texttt{math.tanh(x)} & $tanh(x)$ \\
		\texttt{math.asinh(x)} & $arsinh(x)$ \\
		\texttt{math.acosh(x)} & $arcosh(x)$ \\
		\texttt{math.atanh(x)} & $artanh(x)$ \\
		\texttt{math.hypot(x, y)} & The Euclidean norm, $\sqrt{x^{2} + y^{2}}$ \\
		\texttt{math.factorial(x)} & $x!$ \\
		\texttt{math.erf(x)} & The error function at $x$ \\
		\texttt{math.gamma(x)} & The gamma function at $x$, $\omega(x)$ \\
		\texttt{math.degrees(x)} & Converts $x$ from radians to degrees \\
		\texttt{math.radians(x)} & Converts $x$ from degrees to radians\\
		\bottomrule 
	\end{tabular}
\end{table}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.2 --- advanced mathematical operations with the modules shipped with Python}
# import the math module
>>> import math
	
# base-y log of x
>>> math.log(12, 8)
1.1949875002403856
	
# base-10 log of x
>>> math.log10(12)
1.0791812460476249
	
# import the random module
>>> import random
	
# a draw from a normal distribution with mean = 0 and standard deviation = 1
>>> random.normalvariate(0, 1)
-0.136017752991189

# trigonometric functions
>>> math.cos(0)
1.0

>>> math.sin(0)
0.0

>>> math.tan(0) 
0.0

# an expression containing a factorial product
>>> math.factorial(4) - 4 * 3 * 2 * 1
0
\end{pythoncode}

\begin{paracol}{2}
	\question{Operator precedence}
    \note{As shown in Snippet 4.2, line 30, Python expressions can string together multiple operators. So, how does Python know which operation to perform first? The answer to this question lies in operator precedence. When you write an expression with more than one operator, Python groups its parts according to what are called precedence rules,\footnote{The official Python documentation has an extensive section on operator precedence rules in the section dedicated to \href{https://docs.python.org/3/reference/expressions.html}{syntax of expressions}} and this grouping determines the order in which the expression’s parts are computed. Table \ref{tab:operator_precedence} reports the precedence hierarchy concerning the most common operators. Note that operators lower in the table have higher precedence. Parentheses can be used to create sub-expressions that override operator precedence rules.}
\end{paracol}
\clearpage

\begin{table}[!htbp]
	\centering
	\caption{Operator Precedence Hierarchy \\(Ascending Order)}
	\label{tab:operator_precedence}
	\begin{tabular}{ll}
		\toprule \toprule
        Operator & Description\\ 
        \midrule
        \texttt{x + y}    & Addition, concatenation \\
        \texttt{x - y}    & Subtraction, set difference \\
        \texttt{x * y}    & Multiplication, repetition \\ 
        \texttt{x \% y}   & Remainder, format; \\
        \texttt{x / y}, \texttt{x // y} & Division: true and floor \\
        \texttt{-x}, \texttt{+x} & Negation, identity \\
        \texttt{$^{\sim}$x}       & Bitwise NOT (inversion) \\
        \texttt{x ** y}  & Power (exponentiation) \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{paracol}{2}
	\question{\raggedright Technical and scientific computation with Python}
	\note{Python is at the center of a rich ecosystem of modules for technical and scientific computation. In the following chapter, the attention will revolve around two of the most prominent modules: \href{https://numpy.org/}{NumPy} and \href{https://scipy.org/}{SciPy}. In a nutshell, \href{https://numpy.org/}{NumPy} offers the infrastructure for the efficient manipulation of (potentially massive) data structures, while \href{https://scipy.org/}{SciPy} implements many algorithms across the fields of statistics, linear algebra, optimization, calculus, signal processing,  image processing, and others. Another core module in the technical and scientific domain is \href{https://www.sympy.org/en/index.html}{SimPy}, a library for symbolic mathematics. Note that none of these three modules are shipped with Python and should be installed with the package manager of your choice (e.g., \texttt{conda}).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Variables and Basic Expressions}
	\note{Variables are simply names—created by you or Python—that are used to keep track of information in your program. In Python:
	\begin{itemize}
		\item Variables are created when they are first assigned values
		\item Variables are replaced with their values when used in expressions
		\item Variables must be assigned before they can be used in expressions
		\item Variables refer to objects and are never declared ahead of time
	\end{itemize}
    As Snippet 4.3 shows, the assignment of \texttt{x = 2} causes the variable \texttt{x} to come into existence `automatically.' From that point, we can use the variables in the context of expressions such as the ones displayed in lines 8, 12, 16, and 20, or to create new variables like in line 24.
    }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.3 --- expressions involving arithmetic operations}
	
# let us assign the variables 'x' and 'y' to two number objects
>>> x = 2

>>> y = 4.0	

# subtracting an integer from variable 'x'
>>> x - 1
1

# dividing the variable 'y' by an integer
>>> y / 73
0.0547945205479452

# integer-dividing the variable 'y' by an integer
>>> y // 73
0.0

# getting a linear combination of 'x' and 'y'
>>> 3 * x - 5 * y
-14.0

# assigning the variable 'z' to the linear combination of 'x' and 'y'
>>> z = 3 * x - 5 * y

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Displaying number objects}
	\note{Snippet 4.3 includes some expressions whose result is not passed to a new variable (e.g., lines 8, 12, 16, 20). In those cases, the IPython session displays the outcome of the expression `as is' (e.g., 0.0547945205479452). However, a number with more than three or four decimals may not suit the table or report we have to prepare. Python has powerful \href{https://docs.python.org/3/library/string.html}{string formatting} capabilities to display number objects in a readable and nice manner. Table \ref{tab:number_formatting} illustrates various number formatting options with concrete cases. Format strings contain `replacement fields' surrounded by curly braces \texttt{\{\}}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. Snippet 4.4 presents a fully-fledged number formatting case. First, we assign the variable \texttt{a} to a floating-point number (line 2). Then, we pass the formatting option \texttt{\{:.2f\}} over the variable \texttt{a} using the Python built-in function \href{https://docs.python.org/3/library/stdtypes.html#str.format}{\texttt{format}}.}
\end{paracol}
\clearpage

\begin{table}[!htbp]
	\centering
	\caption{Number Formatting Options in Python}
	\label{tab:number_formatting}
	\begin{tabular}{cccll}
		\toprule \toprule
		\multicolumn{1}{c}{Number} &
		\multicolumn{1}{c}{Format} & 
		\multicolumn{1}{c}{Output} & 
		\multicolumn{1}{c}{Description} \\
		\midrule
		3.1415926                           & \texttt{\{:.2f\}}                            & 3.14                                & Format float 2 decimal places                 &  \\
		3.1415926                           & \texttt{\{:+.2f\}}                           & +3.14                               & Format float 2 decimal places with sign       &  \\
		-1                                  & \texttt{\{:+.2f\}}}                           & -1.00                               & Format float 2 decimal places with sign       &  \\
		2.71828                             & \texttt{\{:.0f\}}                            & 3                                   & Format float with no decimal places           &  \\
		5                                   & \texttt{\{:0\textgreater{}2d\}}              & 05                                  & Pad number with zeros (left padding, width 2) &  \\
		5                                   & \texttt{\{:x\textless{}4d\}}                 & 5xxx                                & Pad number with x’s (right padding, width 4)  &  \\
		10                                  & \texttt{\{:x\textless{}4d\}}                 & 10xx                                & Pad number with x’s (right padding, width 4)  &  \\
		1000000                             & \texttt{\{:,\}}                              & 1,000,000                           & Number format with comma separator            &  \\
		0.25                                & \texttt{\{:.2\%\}}                           & 25.00\%                             & Format percentage                             &  \\
		1000000000                          & \texttt{\{:.2e\}}                            & 1.00e+09                            & Exponent notation                             &  \\
		13                                  & \texttt{\{:10d\}}                            & \multicolumn{1}{r}{13}                                  & Right aligned (default, width 10)             &  \\
		13                                  & \texttt{\{:\textless{}10d\}}                 & \multicolumn{1}{l}{13}                                  & Left aligned (width 10)                       &  \\
		13                                  & \texttt{\{:\textasciicircum{}10d\}}          & 13                                  & Center aligned (width 10)           \\
		\bottomrule
	\end{tabular}
\end{table}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.4 --- number formatting in Python}
# assign the variable 'a' to a floating-point number
>>> a = 0.67544908755

# displaying 'a' with the first two decimals only
>>> "{:.2f}".format(a)
"0.68"

# displaying 'a' with the first three decimals only
>>> "{:.3f}".format(a)
"0.675"
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright{How do I compare number objects?}}
	\note{Comparisons are used frequently to create control \href{https://docs.python.org/3/tutorial/controlflow.html}{flows}, a topic we will discuss later in this chapter. Normal comparisons in Python regard two number objects and return a Boolean result. Chained comparisons concern three or more objects, and, like normal comparisons, yield a Boolean result. Snippet 4.5 provides a sample of normal comparisons (between lines 1 and 15) and chained comparisons (between lines 21 and 30). As evident in the example, comparisons can regard both numbers and variables assigned to numbers. Chained comparisons can take the form of a range test (see line 21), a joined, `AND' test of the truth of multiple expressions (see line 25) or a disjoined, `OR' test of the truth of multiple expressions (see line 29).}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.5 --- comparing numeric objects}
# less than
>>> 3 < 2
False

# greater than or equal
>>> 1 <= 2
True

# equal
>>> 2 == 2
True 

# not equal
>>> 4 != 4
False

# range test
>>> x = 3
>>> y = 5
>>> z = 4
>>> x < y < z
False

# joined test
>>> x < y and y > z
True

# disjoined test
>>> x < y or y < z
True 

\end{pythoncode}

\section{String Type Fundamentals}

\begin{paracol}{2}
	\question{What is a string?}
	\note{A Python string is a positionally ordered collection of other objects. Sequences maintain a left-to-right order among the items they contain: their items are stored and fetched by their relative positions. Strictly speaking, strings are \textit{immutable sequences} of one-character strings; other, more general sequence types include lists and tuples, covered later.}
\end{paracol}

\begin{paracol}{2}
	\question{How do we use strings?}
	\note{Strings are used to record words, contents of text files loaded into memory, Internet addresses, Python source code, and so on. Strings can also be used to hold the raw bytes used for media files and network transfers, and both the encoded and decoded forms of non-ASCII Unicode text used in internationalized programs.}
\end{paracol}

\begin{paracol}{2}
	\question{Is \texttt{abc} a Python string?}
	\note{Nope. Python strings are enclosed in single quotes (`...') \textit{or} double quotes (``...'') with the same result. Hence, ``\texttt{abc}'' can be Python string, while \texttt{abc} cannot. \texttt{abc} can be a variable name, though.}
\end{paracol}

\begin{paracol}{2}
	\question{String indexing and slicing}
	\note{The fact that strings are immutable sequences affects how we manipulate textual data in Python. In Snippet 4.6, we fetch the individual elements of \texttt{S}, a variable assigned to ``\texttt{Python 3.X}.'' As per the built-in function \href{https://docs.python.org/3/tutorial/introduction.html#strings}{\texttt{len}}, \texttt{S} contains six unitary strings. That means that each element in \texttt{S} is associated with a position in the numerical progression $\{0, 1, 2, 3, 4, 5\}$. Now, you may be surprised to see the first element of the list is $0$ instead of $1$. The reason is that Python is a zero-based indexed programming language: the first element of a series has index $0$, while the last element has index \texttt{len(obj)} - 1.  Fetching the individual elements of a string, such as \texttt{S}, requires passing the desired index between brackets, as shown in line 9 (where we get the first unitary string, namely, ``\texttt{P}''.), line 13 (where we get the last unitary string, namely, ``\texttt{X}''), and line 21 (where we get the unitary string with index $3$, i.e., the fourth unitary string appearing in \texttt{S}, ``\texttt{h}''). Note that line 17 is an alternative indexing strategy to the one presented in line 13: it is possible to retrieve the last unitary string by counting `backward'; that is, getting the first element starting from the right-hand side of the string, which equates to index \texttt{-1}. In lines 26 and 30, we exploit the indices of \texttt{S} to retrieve multiple unitary strings in a row. What we pass among brackets is not a single index. Instead, we specify a range of indices \texttt{i:j}. It is wort noticing that, in Python, the element associated with the lower bound index \texttt{i} is returned, whereas the element associated with the upper bound index \texttt{j} is not. In line 26, we fetch the unitary strings between index \texttt{2} --- equating to third unitary string of \texttt{S} --- and index \texttt{5} excluded --- namely, the fifth unitary string of \texttt{S}. In line 30, we adopt the `backward' approach to retrieve the unitary string with index \texttt{-3} --- the third string counting from the right-hand side of \texttt{S} --- as well as any other unitary strings following index \texttt{-3}. To do that, we leave the upper bound index blank.} 
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.6 --- Python strings as sequences}
# let us assign the string "Python 3.X" to the variable S
>>> S = "Python 3.X"

# check the length of S
>>> len(S)
6

# access the first unitary string in the sequence behind S 	
>>> S[0]
"P"

# access the last unitary string in the sequence behind S
>>> S[len(S)-1]
"X"

# or, equivalently
>>> S[-1]
"X"

# access the i-th, e.g., 3rd, unitary string in the sequence behind S
>>> S[3]
"h"

# access the unitary strings between the i-th and j-th positions in the 
# sequence behind S
>>> S[2:5]
"tho"

# access the unitary strings following the i-th position in the sequence 
# behind S
>>> S[-3:]
"3.X"

\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Common string literals and operators}
	\note{Snippet 4.6 deals with string indexing and slicing, two of the many operations we can carry out on strings. Table \ref{tab:string_literals_and_operators} reports a sample of common string literals and operators. The first two lines of Table \ref{tab:string_literals_and_operators} remind us that single and double quotes are equivalent when it comes to assigning a variable to a string object. However, we must refrain from mixing and matching single and double quotes. In other words, a string object requires the leading and trailing quotes are of the same type (i.e., double-double or single-single). In the interest of consistency, it is a good idea to make a policy choice, such as ``in my Python code, I use double quotes only'', and to stick with that throughout the various lines of the script. I prefer using double quotes because the single quote symbol is relatively popular in natural language (consider for example the Saxon genitive). As shown in the third line of Table \ref{tab:string_literals_and_operators} the single quote is treated as a unitary string insofar as double quotes are used to delimit the string object. Should the string object be delimited by single quotes, we should tell Python not to treat the single quote symbol after \texttt{m} as a Python special character but as a unitary string. To do that, we use the escape symbol $\setminus$  as shown in the fourth line of Table \ref{tab:string_literals_and_operators}. Table \ref{tab:helpful_escapes} provides several escaping examples.}
\end{paracol}
\clearpage

\begin{table}[!htbp]
	\centering
	\caption{Sample of String Literals and Operators}
	\label{tab:string_literals_and_operators}
	\begin{tabular}{ll}
		\toprule \toprule
		Literal/operation & Interpretation \\
		\midrule
		\texttt{S = ""}} &  Empty string \\
		\texttt{S = `'} &   Single quotes, same as double quotes \\
		\texttt{S = "spam's"} & Single quote as a string \\
		\texttt{S = `spam$\setminus$'s'} & Escape symbol \\
		\texttt{length(S)} & Length \\
		\texttt{S[i]} & Index \\
		\texttt{S[i:j]} & Slice \\
		\texttt{S1 + S2} & Concatenate \\
		\texttt{S * 3} & Repeat S $n$ times (e.g., three times)\\
		\texttt{"text".join(strlist)} & Join multiple strings on a character (e.g., ``text'')\\
		\texttt{"\{\}".format()} & String formatting expression \\ 
		\texttt{S.strip()} & Remove white spaces \\
		\texttt{S.replace("pa", "xx")} & Replacement \\
		\texttt{S.split(",")} & Split on a character (e.g., ``,'') \\
		\texttt{S.lower()} & Case conversion --- to lower case \\
		\texttt{S.upper()} & Case conversion --- to upper case \\
        \texttt{S.find("text")} & Search substring (e.g., "text") \\
		\texttt{S.isdigit()} & Test if the string is a digit \\
		\texttt{S.endswith("spam")} & End test \\
        \texttt{S.startswith("spam")} & Start test \\
		\texttt{S = """...multiline..."""} & Triple-quoted block strings \\
		\bottomrule
	\end{tabular}
\end{table}

\begin{paracol}{2}
	\question{\raggedright String manipulation tasks}
		\note{Snippet 4.7 presents a sample of miscellaneous string manipulation tasks. In lines 6 and 9, we check the length of the variables \texttt{S1} and \texttt{S2}. In line 13, we display five repetitions of \texttt{S1}. In line 17, we use the algebraic operator ``$+$'' to concatenate \texttt{S1} and \texttt{S2}. In line 21, we expand on the previous input by separating \texttt{S1} and \texttt{S2} by a white-space. In line 25, we carry out the same task as line 17 --- however, we rely on the built-in \href{https://docs.python.org/3/library/stdtypes.html#str.join}{\texttt{join}} function to join \texttt{S1} and \texttt{S2} with whitespace. The argument taken by \href{https://docs.python.org/3/library/stdtypes.html#str.join}{\texttt{join}} is a Python \texttt{list}, the subject of paragraph 5.3. In line 29, \texttt{S1} and \texttt{S2} are joined with a custom string object, namely, \texttt{" Vs. "}. Finally, in line 33, we use the built-in \href{https://docs.python.org/3/library/stdtypes.html#str.format}{\texttt{format}} function (see also Snippet 4.4) to display a string object including \texttt{S1} and \texttt{S2}. For a comprehensive list of string methods, see Table \ref{tab:string_methods}.}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.7 --- miscellaneous string manipulation tasks}
# let us assign S1 and S2 to two strings
>>> S1 = "Python 3.X"
>>> S2 = "Julia"

# check the length of S1 and S2
>>> len(S1)
10

>>> len(S2)
5

# display the S1 repeated five times
>>> S1 * 5
"Python 3.XPython 3.XPython 3.XPython 3.XPython 3.X"

# display the concatenation of S1 and S2
>>> S1 + S2
"Python 3.XJulia"

# display the concatenation of S1, whitespace, and S2
>>> S1 + " " + S2
"Python 3.X Julia"

# display the outcome of joining S1 and S2 with a whitespace
>>> " ".join([S1, S2])
"Python 3.X Julia"

# display the outcome of joining S1 and S2 with an arbitrary string object
>>> " Vs. ".join([S1, S2])
"Python 3.X Vs. Julia"

# string formatting
>>> "Both {} and {} have outstanding ML modules".format(S1, S2) 
"Both Python 3.X and Julia have outstanding ML modules"
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright String editing}
	\note{Snippet 4.8 illustrates some string editing tasks. In line 5, we use \href{https://docs.python.org/3/library/stdtypes.html#str.format}{lstrip} --- a variation of the built-in function \href{https://docs.python.org/3/library/stdtypes.html#str.format}{strip} --- that returns a copy of the string with leading characters removed. In line 9, we use the built-in \href{https://docs.python.org/3/library/stdtypes.html}{replace} to return a copy of the string with all occurrences of substring \texttt{old} (first argument taken by the function) replaced by \texttt{new} (second argument taken by the function). Finally, in line 17, we use the built-in function \href{https://docs.python.org/3/library/stdtypes.html}{\texttt{lower}} to return a copy of the string with all the cased characters converted to lowercase.} 
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.8 --- miscellaneous string editing tasks}
# let us assign S to a string object
>>> S = "Both Python 3.X and Julia have outstanding ML modules"

# strip target leading characters
>>> S.lstrip("Both ")
"Python 3.X and Julia have outstanding ML modules"

# replace target characters
>>> S.replace("Python 3.X", "R")
"Both R and Julia have outstanding ML modules"

# split string on target characters
>>> S.split(" and ")
["Both Python 3.X", "Julia have outstanding ML modules"]

# make the string lower case
>>> S.lower() 
"both python 3.x and julia have outstanding ml modules"
\end{pythoncode}
\clearpage

\begin{paracol}{2}
\question{Testing and searching strings}
\note{Snippet 4.9 presents a series of string test and search tasks. The built-in function \href{https://docs.python.org/3/library/stdtypes.html}{\texttt{find}} (see lines 5 and 9) returns the lowest index in the string where substring sub is found within the slice \texttt{S[start:end]} or -1 if substring is not found.	The built-in function \href{https://docs.python.org/3/library/stdtypes.html}{\texttt{isdigit}} return \texttt{True} if all characters in the string are digits and there is at least one character, \texttt{False} otherwise. Finally, the built-in function \href{https://docs.python.org/3/library/stdtypes.html}{endswith} returns \texttt{True} if the string ends with the specified suffix, otherwise returns \texttt{False}.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.9 --- miscellaneous string test and search tasks}
# let us assign S to a string object
>>> S = "The first version of Python was released in 1991"

# search for "Python" in S
>>> S.find("Python")
21

# search for "Julia" in S
>>> S.find("Julia")
-1

# slice the string the get Python's release year information
>>> SS = S[-4:]

# display SS
>>> SS
"1991"

# test if all characters in SS are digits
>>> SS.isdigit()
True

# test if all characters in SS are digits
>>> SS.isdigit()
True

# test if all characters in SS are digits
>>> SS.isdigit()
True

# test if S ends with "1991" / SS
>>> S.endswith(SS)
True
\end{pythoncode}
\clearpage

\begin{paracol}{2}
\question{\raggedright Multiline string printing}
\note{In the previous examples, we came across the built-in function \href{https://docs.python.org/3/library/functions.html#print}{\texttt{print}}. Such a function can be used to print both number- and string-type objects. Sometimes, what we want to print fits into a single line. In other circumstances, we are interested in visualizing rich data, which can span multiple lines. Snippet 4.9 how to print objects across multiple lines with the triple-quoted block string (see line ). As evident from the Python code included in lines 8-13, any line between triple-quotes is considered part of the same string object.}	
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.9 --- multiline string printing}
# single-line print
>>> print("Hello world!")
Hello world!

# multi-line print
>>> print(
... """
... =======================================================
... COL A       | COL B      | ...        | COL K
... -------------------------------------------------------
... Sheldon     | Cooper     | ...        | bazinga.com
... -------------------------------------------------------
... NOTES: this table has fake data
... """
... )

=======================================================
COL A       | COL B      | ...        | COL K
-------------------------------------------------------
Sheldon     | Cooper     | ...        | bazinga.com
-------------------------------------------------------
NOTES: this table has fake data

\end{pythoncode}

\section{List and Dictionaries}

\begin{paracol}{2}
	\question{\raggedright What is a list?}
		\note{A Python \href{https://docs.python.org/3/tutorial/datastructures.html}{\texttt{list}} is an \emph{ordered}, \emph{mutable} array of objects. A list is constructed by specifying the objects, separated by commas, between square brackets, \texttt{[]}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Why do we use lists?}
	\note{Lists are just places to collect other objects so you can treat them as groups.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What type of objects can we include in a list?}
	\note{Lists can contain any sort of object: numbers, strings, and even other lists. See Snippet 4.10.}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.10 --- sample lists with different items}
# an empty list
>>> L = [] 

# a list with an integer, a float, and a string
>>> L = [2, -3.56, "XyZ"]

# a list with an integer and a list
>>> L = [4, ["abc", 8.98]]

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright List indexing}
	\note{We can retrieve one or more list component objects via indexing. That is possible because list items are ordered by their position  (similarly to strings). Since Python is a zero-based indexed programming language, to fetch the first item of a list we have to call the index \texttt{0} (see Snippet 4.11, line 5). A list nested in another list can be fetched by using multiple indices (line 13). The first index refers to the outer list, while any subsequent index refers to an inner list. In our case, we have two indices, one for each list; that is, \texttt{L} and its sub-list \texttt{["abc", 8.98]}.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.11 --- list indexing and slicing}
# the list
>>> L = [4, ["abc", 8.98]]

# get the first item of L
>>> L[0]
4

 # get the second element of L
>>> L[1]
["abc", 8.98]

# get the first item of L's second item
>>> L[1][0]
"abc"

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright List mutability}
	\note{Lists are mutable objects, which may be changed in place by assignment to offsets and slices, list method calls, deletion statements, and more. Snippet 4.12 illustrates some snippets to change a list's items. In the first part of the example, we change the items using indexing (line 5) and slicing (line 10). In the second half, we use Python's \href{https://docs.python.org/3/reference/simple_stmts.html}{\texttt{del}} statement to delete the items using indexing (line 15) and slicing (line 20).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.12 --- changing and deleting list items in place}
# the list
>>> L = ["Leonard", "Penny", "Sheldon"]

# change the second item of L via indexing
>>> L[1] = "Raj"
>>> print(L)
["Leonard", "Raj", "Sheldon"]

# change multiple items of L via slicing
>>> L[0:2] = ["Amy", "Howard"]
>>> print(L)
["Amy", "Howard", "Sheldon"]

# delete the first item of L via indexing and using the 'del' statement
>>> del L[0]
>>> print(L)
["Howard", "Sheldon"]

# delete multiple items of L via slicing and using the 'del' statement
>>> del L[0:2]
>>> print(L)
[]

\end{pythoncode}

\begin{paracol}{2}
\question{\raggedright List manipulation with built-in methods}
\note{Python offers many \href{https://docs.python.org/3/tutorial/datastructures.html}{methods to manipulate and test list objects}. Table \ref{tab:list_methods} reports some of the most popular methods along with synopses. The first three methods --- \texttt{.append()}, \texttt{.insert()}, and \texttt{.extend()} --- expand an existing list. The fourth method, \texttt{.index} test for the presence of an item in an existing list. Note this method raises a \href{https://docs.python.org/3/library/exceptions.html#ValueError}{\texttt{ValueError}} if there is no such item.The remaining methods produce in-place changes in an existing list's items.}
\end{paracol}

\begin{table}[!htbp]
	\caption{Popular list methods}
	\label{tab:list_methods}
	\centering
	\begin{tabular}{ll}
		\toprule \toprule
		Method & Synopsis \\
		\midrule 
		\texttt{L.append(X)} & Append an item to an existing list\\
		\texttt{L.insert(i, X)} & Append an item to an exisintg list in position $i$ \\
		\texttt{L.extend([X0, X1, X2])} & Extend an existing list with the items from another list\\
		\texttt{L.index(X)} & Get the index of the first instance of the argument in an existing list\\
		\texttt{L.count(X)} & Get the cardinality of an item in an existing list\\
		\texttt{L.sort()} & Sort the items in an existing list\\
		\texttt{L.reverse()} & Reverse the order of the items in an existing list\\
		\texttt{L.copy()} & Get a copy of an existing list\\
		\texttt{L.pop(i)} & Remove the item at the given position in the list, and return it\\
		\texttt{L.remove(X)} & Remove the first instance of an item in an existing list\\
		\texttt{L.clear()} & Remove all items in an existing list\\
		\bottomrule 
	\end{tabular}
\end{table}

\begin{paracol}{2}
	\question{\raggedright Expanding an existing list}
	\note{Both the \texttt{.append()} and \texttt{.extend()} methods can be used to expand an existing list as per Snippet 4.13. However, they accomplish different goals and should not be confused: \texttt{.append()} adds a new item (of any type) to the end of the list (see line 6); \texttt{.extend()} extend the list by appending all the items from another iterable (e.g., another list, see line 11).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.13 --- methods for expanding an existing list}
# create two lists 
>>> L1 = ["Leonard", "Penny", "Sheldon"]
>>> L2 = ["Howard", "Raj", "Amy", "Bernadette"]

# expand an existing list with .append()
>>> L2.append("Priya") 
>>> print(L2)
["Howard", "Raj", "Amy", "Bernadette", "Priya"]

# concatenate L1 and L2 with .extend()
>>> L1.extend(L2)
>>> print(L1)
["Leonard", "Penny", "Sheldon", "Howard", "Raj", "Amy", "Bernadette", "Priya"]

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright In-place change of an existing list's items}
	\note{One of the most common list manipulation task consists of changing the order of an item's list. As shown in Snippet 4.14, it is possible to use the \texttt{.reverse()} method to reverse the elements of the list in place (see line 5), while sorting an item's list can be carried out with the \texttt{.sort()} method.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.14 --- methods for changing list items in place}
# create a list 
>>> L = ["Howard", "Raj", "Amy", "Bernadette", "Priya"]

# reverse the list's item positions
>>> L.reverse()
>>> print(L)
["Priya", "Bernadette", "Amy", "Raj", "Howard"]

# sort the list's items
>>> L.sort()
>>> print(L)
["Amy", "Bernadette", "Howard", "Priya", "Raj"]

\end{pythoncode}
\clearpage

\section{Dictionaries}
\label{sec:dictionaries}

\begin{paracol}{2}
	\question{\raggedright What is a dictionary?}
	\note{Along with lists, dictionaries are one of the most flexible built-in data types in Python. If you think of lists as ordered collections of objects, you can think of dictionaries as unordered collections; the chief distinction is that in dictionaries, items are stored and fetched by \emph{key}, instead of by \emph{positional offset}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Why do we use dictionaries?}
	\note{Dictionaries take the place of records, search tables, and any other sort of aggregation where item names are more meaningful than item positions.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What type of objects can we include in a dictionary?}
	\note{Like lists, dictionaries can contain objects of any type, and they support nesting to any depth(they can contain lists, other dictionaries, and so on). Each key can have just one associated value, but that value can be a collection of multiple objects if needed, and a given value can be stored under any number of keys.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we create a dictionary?}
	\note{Snippet 4.15 shows two different ways to create a dictionary. A dictionary can be created by including key-value pairs among braces (see line 2). In the example, there are three keys, associated with Marvel characters, and as many values, which can be thought as the characters' position in an ideal power rank. A colon separates a key and its associated value. The second way to create a dictionary is based on Python's builtin \href{https://docs.python.org/3/library/stdtypes.html#dict}{\texttt{dict}}, mapping key onto values, and \href{https://docs.python.org/3/library/functions.html#zip}{\texttt{zip}}, which iterates over two elements in parallel. Specifically, \href{https://docs.python.org/3/library/functions.html#zip}{\texttt{zip}} creates the one-to-one correspondence between keys (characters) and values (characaters' power) that is passed as the argument of \href{https://docs.python.org/3/library/stdtypes.html#dict}{\texttt{dict}}. We will analyze the topic of iterations extensively in sections \ref{sec:while_and_for_loops} and \ref{sec:iterations_and_comprhensions}.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.15 --- initializing a new dictionary object}
# method 1 
>>> D = {"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}

# method 2
>>> CHARACTERS = ["Captain Marvel", "Living Tribunal", "One-Above-All"]
>>> RANK = [3, 2, 1]
>>> D = dict(zip(CHARACTERS, RANK)) 
>>> print(D)
{"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Accessing a dictionary's values}
	\note{Dictionaries' items cannot be accessed via positional offsets --- like lists. Instead, we fetch the individual items by using the dictionary keys as shown in Snippet 4.16 (see line 5). The reference key is passed among brackets. When the dictionary at hand contains nested dictionaries (see line 9), it is possible to concatenate multiple queries, namely, sequences of keys between brackets (see line 21).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.16 --- fetching dictionary items}
# the dictionary 
>>> D = {"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}

# let's fetch Captain Marvel's position in the Marvel characters' power rank
>>> D["Captain Marvel"]
3

# a dictionary of dictionaries
>>> D = {
	"Dr. Strange": {
		"first_appearance": 1963,
		"created_by": "Lee & Ditko"
		},
	"Iron Man": {
		"first_appearance": 1963,
		"created_by": "Lee, Lieber, Heck & Kirby"
		},
    } 

# let us fetch the creator of Dr. Strange 
>>> D["Dr. Strange"]["created_by"]
"Lee & Ditko"
\end{pythoncode}

\begin{paracol}{2}
\question{\raggedright Are dictionaries mutable?}
\note{Dictionsries, like lists, are mutable. Thus, we can change, expand, and shrink them in place without making new dictionaries: simply assign a value to a key to change or create an entry. The del statement works here, too; it deletes the entry associated with the key specified as an index (see Snippet 4.17).}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.17 --- dictionary mutability examples}
# the dictionary 
>>> D = {"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}

# let us change the power rank for Captain Marvel
>>> D["Captain Marvel"] = 12
>>> print(D)
{"Captain Marvel": 12, "Living Tribunal": 2, "One-Above-All": 1}

# let us eliminate the character Living Tribunal 
>>> del D["Living Tribunal"]
>>> print(D)
{"Captain Marvel": 12, "One-Above-All": 1}

# let us add a further character 
>>> D["Wanda Maximoff"] = 4
>>> print(D)
{"Captain Marvel": 12, "One-Above-All": 1, "Wanda Maximoff": 4}

\end{pythoncode}

\begin{paracol}{2}
\question{\raggedright Dictionary manipulation with built-in methods}
\note{Like for lists, Python offers many \href{https://docs.python.org/3/tutorial/datastructures.html#dictionaries}{\texttt{methods to manipulate dictionary objects}}. Table \ref{tab:dictionary_methods} reports some of the most common methods along with synopses. The first three methods, \texttt{.keys()} \texttt{.values()} \texttt{.items()}, get the constitutive elements of dictionaries: keys, values, and key-value pairs respectively. The fourth method, \texttt{.get(key, default?)} gets the value for a specific key. The fifth method, \texttt{.update()}, updates the value for a specific key. Like \texttt{.update()}, \texttt{.popitem()}, \texttt{.pop()}, and \texttt{d.clear()} alter the information of a dictionary in place. The first removes the value of a certain key; the second removes the item (a key-value pair) for a certain key; the latter delete all dictionary items. Finally, \texttt{.copy()} creates a \href{https://docs.python.org/3/library/copy.html}{shallow copy} of an existing dictionary.}
\end{paracol}

\begin{table}[!htbp]
	\caption{Popular dictionary methods}
	\label{tab:dictionary_methods}
	\centering
	\begin{tabular}{ll}
		\toprule \toprule
		Method & Synopsis \\
		\midrule 
		\texttt{D.keys()} & Get all dictionary keys\\
		\texttt{D.values()} & Get all dictionary values \\ 
		\texttt{D.items() } & Get all dictionary key-value pairs as tuples \\
		\texttt{D.get(key, default?)} & Query a dictionary element by key\\ 
		\texttt{D.update(D2) } & Update a dictionary key's value\\
		\texttt{D.popitem()} & Remove the value corresponding to a certain key \\ 
		\texttt{D.pop(key, default?) } & Remove the item at the given position in the list,\\
		\texttt{D.clear() } & Delete all dictionary items\\
		\texttt{D.copy() } & Copy the target dictionary \\
		\bottomrule 
	\end{tabular}
\end{table}

\begin{paracol}{2}
\question{\raggedright How do we access the information in a dictionary?}
\note{Snippet 4.18 shows how to use builtin methods to carry out three fundamental tasks: accessing dictionary keys (see line 5), values (see line 9), and items (i.e., key-value pairs, see line 13). It is worth noticing that the three methods illustrated in the example yield specific \href{https://docs.python.org/3/c-api/dict.html}{dictionary objects} such as \texttt{dict\_keys}, \texttt{dict\_values}, and \texttt{dict\_items}. Translating one of these dictionary objects into a list --- if needed --- is straightforward (see line 17).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.18 --- accessing the information included in a dictionary}
# the dictionary 
>>> D = {"Captain Marvel": 3, "Living Tribunal": 2, "One-Above-All": 1}

# get the keys
>>> D.keys()
dict_keys(["Captain Marvel", "Living Tribunal", "One-Above-All"])

# get the values 
>>> D.values()
dict_values([3, 2, 1])

# get the items
>>> D.items()
dict_items([("Captain Marvel", 3), ("Living Tribunal", 2), ("One-Above-All", 1)])

# get the keys as a list 
>>> list(D.keys())
["Captain Marvel", "Living Tribunal", "One-Above-All"]
\end{pythoncode}

\section{Tuples}

\begin{paracol}{2}
	\question{\raggedright What is a tuple?}
	\note{Tuples are sequences of immutable Python objects. They are similar to lists, but they are immutable. Tuples are created by enclosing a comma-separated list of values in parentheses.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Tuples are immutable!}
	\note{Tuples are immutable, which means that once they are created, they cannot be changed!! }
\end{paracol}

\begin{paracol}{2}
\question{\raggedright Why do we use tuples?}
\note{Tuples are useful for storing data that is not to be changed, such as the coordinates of a point in a two-dimensional space. In general, we use tuples any time information integrity is a concern --- in other words when we want to make sure the information included in an object will not change because of another reference somewhere in our program.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we create a tuple?}
	\note{Python objects, separated by a comma, must be included between parentheses (see Snippet 4.19, line 2).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we access the information in a tuple?}
	\note{By positional offsets, like lists (see Snippet 4.19, lines 5 and 9).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.19 --- creating and accessing a tuple}
# the tuple
>>> T = ("Captain Marvel", 3)

# access a tuple element
>>> T[0]
"Captain Marvel"

# access a tuple element
>>> T[1]
3
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Can we convert a tuple into a list?}
	\note{Yes, we can. To do that, we pass the tuple as the argument of \texttt{list} (see Snippet 4.20).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.20 --- tuple conversion}
>>> T = ("Captain Marvel", 3)

# from a tuple to a list
>>> L = list(T)
>>> print(L)
["Captain Marvel", 3]

# amend L's items
>>> L[1] = 4

# get back to a tuple
>>> T = tuple(L)
>>> print(T)
("Captain Marvel", 4)
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Tuples with the \href{https://docs.python.org/3/library/collections.html}{\texttt{collections}} module}
	\note{\href{https://docs.python.org/3/library/collections.html}{\texttt{collections}} is a module that is shipped with Python and provides data containers that are alternative to Python's general purpose built-in containers, i.e., \texttt{dict}, \texttt{list}, \texttt{set}, and \texttt{tuple}. One of these containers can be created with the function \href{https://docs.python.org/3/library/collections.html#collections.namedtuple}{\texttt{namedtuple}} (see Snippet 4.21), which allows annotating the tuple items with names. In line 2, we import the function \href{https://docs.python.org/3/library/collections.html#collections.namedtuple}{\texttt{namedtuple}} from the \href{https://docs.python.org/3/library/collections.html#collections}{\texttt{collections}} module. In line 5, we create an ad hoc class that best represents the structure of our sample data, concerning Marvel characters' names and the year in which they first appeared in the comic series. The first argument taken by the function is customary and regards the name of the class we are about to create. The second argument is a list with the names of the attributes included in our data structure. In line 8, we use the newly created class \texttt{Rec} to create a tuple, which is eventually printed as per line 11.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.21 --- creating an annotated tuple with the collection module}
# import the namedtuple function from the module collection
>>> from collections import namedtuple

# create an ad hoc class object 'Rec' that fits our data structure
>>> Rec = namedtuple("Rec", ["character", "first_appearance"])

# use the generated class "Rec"
>>> IRONMAN = Rec("Iron Man", 1963)

# A named-tuple record
>>> IRONMAN
Rec(character="Iron Man", first_appearance=1963)
\end{pythoncode}

\section{Sets}

\begin{paracol}{2}
	\question{\raggedright What is a set?}
	\note{A \href{https://docs.python.org/3/tutorial/datastructures.html#sets}{\texttt{set}} is an \emph{unordered} collection of \emph{unique} and \emph{immutable} objects.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What does it mean that sets are unordered collections?}
	\note{By design, \href{https://docs.python.org/3/tutorial/datastructures.html#sets}{\texttt{set}} is a data structure with \emph{undefined element ordering} (see Snippet 4.22 --- the outcome included in line 6 does not follow any particular order).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What does it mean that sets have unique items?}
	\note{By definition, an item appears only once in a set, no matter how many times it is added (see Snippet 4.22, line 2 Vs. line 7).}
\end{paracol}

\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.22 --- creating a set}
# create a list
>>> L = ["a", "a", "b", "c", "c"]

# get a set from L
>>> S = set(L)
>>> print(S)
{"b", "a", "c"}
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Why do we use sets?}
	\note{Sets made this way support common mathematical set operations (see Snippet 4.23). Hence, they have a variety of applications, especially in numeric and database-focused work. }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.23 --- set operations}
# create two sets 
>>> X = set(["a", "b", "c"])
>>> Y = set(["c", "d", "e"])

# set difference 
>>> X - X
set()
>>> X - Y
{"a", "b"}

# union
>>> X | Y
{"a", "b", "c", "d", "e"}

# intersection
>>> X & Y
{"c"}

# superset
>>> X > Y
False

# subset
>>> X < Y
False
\end{pythoncode}
\clearpage

\section{Files}

\begin{paracol}{2}
	\question{\raggedright How do the files in our OS relate with Python?}
	\notion{Our Python program may involve input and/or output operations. In other words, we may want to read data from a file stored in our machine and/or write the outcome of our analysis to a file. The built-in function \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}} creates a Python file object, which serves as a link to a file residing on your machine. As Lutz notes:
	\begin{quote}
		\textit{
		``Compared to the types you've seen so far, file objects are somewhat unusual. They are considered a core type because they are created by a built-in function, but they're not numbers, sequences, or mappings, and they don't respond to expression operators; they export only methods for common file-processing tasks'' (page 282)
		}
	\end{quote}}
\end{paracol}

\begin{paracol}{2}
\question{\raggedright How do we open a file?}
\note{We open a pipe to a file using the built-in function \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}}. The output of the function is a \texttt{file} object. }
\end{paracol}

\begin{paracol}{2}
\question{\raggedright How do we source the data stored in a file?}
\note{We open a pipe to a file using the built-in function \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}}. The output of the function is a \texttt{file} object. Snippet 4.24 illustrates how to use \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}} for data sourcing. In the first part of the snippet, we create a \texttt{file} object to read the data included in the existing file \texttt{my\_file.txt}.\footnote{For the sake of simplicity, we assume the target file is located in the same directory as the Python script.} At least, we have to pass one argument to \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}}: the path pointing to the file. A second optional argument is \texttt{mode}, which specifies the mode in which the file is opened to source. It defaults to \texttt{r}, which means open for reading in text mode. Other common values are \texttt{w} for writing,\footnote{By deafult, \texttt{w} truncates the file if it already exists} \texttt{x} for exclusive creation, and \texttt{a} for appending. \footnote{If encoding is not specified the encoding used is platform-dependent. Specifically, \texttt{locale.getpreferredencoding(False)} is called to get the current locale encoding. Character encoding is the process of assigning numbers to graphical characters, especially the written characters of human language, allowing them to be stored, transmitted, and transformed using digital computers.} To read a file's contents, we use the \href{https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects}{\texttt{.read()}} method (see line 9), returning a string object (see line 10). }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.24 --- data input with \texttt{open}}
# create a pipe to a file
>>> file = open(file="my_file.txt", mode="r")

# calling "file" yields the attributes of the file object
>>> file
<_io.TextIOWrapper name="my_file.txt" mode="r" encoding="UTF-8">

# let us source the data
>>> data = file.read()
>>> print(data)
Hi there

# close the pipe
>>> file.close()
\end{pythoncode}
\clearpage 

\begin{paracol}{2}
\question{\raggedright How do we write the data in the current Python session to a file?}
\note{Snippet 4.25 illustrates how to use \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open}} for data writing. In the first part of the snippet, we create three strings --- i.e., the information we are manipulating in the active Python session (see lines 2, 4, and 6). Then, we create a file object in `writing' mode (see the value passed to \texttt{mode}, line 9). Finally, we manipulate the three strings (as a sample task, in line 12, we concatenate \texttt{FIRSTLAW}, \texttt{SECONDLAW}, \texttt{THIRDLAW}) and write the result to a file (line 16).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.25 --- data output with \texttt{open}}
# the strings (data) to save permanently to a file
>>> FIRSTLAW = "A robot may not injure a human being or, through inaction, "\
	       "allow a human being to come to harm."
>>> SECONDLAW = "A robot must obey the orders given it by human beings except "\
	       "where such orders would conflict with the First Law."
>>> THIRDLAW = "A robot must protect its own existence as long as such "\
               "protection does not conflict with the First or Second Law."

# create a pipe to a file
>>> file = open(file="my_file.txt", mode="w")

# concatenate the strings
>>> TO_WRITE = "\n".join([FIRSTLAW, SECONDLAW, THIRDLAW])

# write the concatenated strings 
>>> file.write(TO_WRITE)

# close the pipe
>>> file.close()
\end{pythoncode}
	
\begin{paracol}{2}
	\question{\raggedright How about reading a single line from a file?}
	\note{Hold on: what is a line? A string whose last character is \texttt{$\backslash$n}. We can read a single line from a file using the \href{https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects}{\texttt{.readline()}} method (see Snippet 4.26). Such a method starts by reading the first line included in the file (see line 11); then, it reads any subsequent lines included in the file (see line 15); when it reaches the end of the file (EOF), it returns the empty string \texttt{""} (see line 19).}
\end{paracol}
\clearpage 

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.26 --- reading one line at a time with \texttt{.readline()}}
# the strings (data) to save permanently to a file
>>> DATA = "The first line\nThe second line" 

# create a pipe to a file and write DATA
>>> file = open(file="my_file.txt", mode="w")
>>> file.write(DATA)
>>> file.close()

# read one line from the file
>>> file = open(file="my_file.txt", mode="r")
>>> file.readline()
"The first line\n"

# calling file.readline() again reds the subsequent line 
>>> file.readline()
"The second line"

# ... and so on until the end of the file is reached
>>> file.readline()
""
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright How about reading multiple lines at a time?}
	\note{The \texttt{.readlines()} method reads the lines from a file and returns them as a list (see Snippet 4.27).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.27 --- reading multiple lines at a time with \texttt{.readlines())}}
# the strings (data) to save permanently to a file
>>> DATA = "A\nB\nC\nD" 

# create a pipe to a file and write DATA
>>> file = open(file="my_file.txt", mode="w")
>>> file.write(DATA)
>>> file.close()

# read multiple lines 
>>> file = open(file="my_file.txt", mode="r")
>>> file.readlines()
['A\n', 'B\n', 'C\n', 'D']

# equivalently to the previous line, we can use 'list'
['A\n', 'B\n', 'C\n', 'D']
\end{pythoncode}	

\begin{paracol}{2}
	\question{\raggedright What are the most common file methods?}
	\note{Table \ref{tab:file-methods} illustrates some key file methods' names and their corresponding synopsis.}
\end{paracol}

\begin{table}[!htbp]
	\caption{Popular file methods}
	\label{tab:file-methods}
	\centering
	\begin{tabular}{ll}
		\toprule \toprule
		Method       & Description                                                                          \\
		\midrule
		\texttt{file.close()     } & Closes the file                                                                      \\
		\texttt{file.detach()    } & Returns the separated raw stream from the buffer                                     \\
		\texttt{file.fileno()    } & Returns a number that represents the stream as per the OS' perspective \\
		\texttt{file.flush()     } & Flushes the internal buffer                                                          \\
		\texttt{file.isatty()    } & Returns whether the file stream is interactive or not                                \\
		\texttt{file.read()      } & Returns the file content                                                             \\
		\texttt{file.readable()  } & Returns whether the file stream can be read or not                                   \\
		\texttt{file.readline()  } & Returns one line from the file                                                       \\
		\texttt{file.readlines() } & Returns a list of lines from the file                                                \\
		\texttt{file.seek()      } & Change the file position                                                             \\
		\texttt{file.seekable()  } & Returns whether the file allows us to change the file position                       \\
		\texttt{file.tell()      } & Returns the current file position                                                    \\
		\texttt{file.truncate()  } & Resizes the file to a specified size                                                 \\
		\texttt{file.writable()  } & Returns whether the file can be written to or not                                    \\
		\texttt{file.write()     } & Writes the specified string to the file                                              \\
		\texttt{file.writelines()} & Writes a list of strings to the file                                                 \\
		\bottomrule \\[-1.8ex]
		\multicolumn{2}{l}{Notes: \texttt{file} is a fictionary object used to illustrate the usage of the file methods.} \\
	\end{tabular}
\end{table}

\section{Python Statements and Syntax}

\begin{paracol}{2}
	\question{\raggedright What is a Python statement?}
	\note{In his popular book `Learning Python,' Lutz provides a concise and effective description of what a Python statement is:
		\begin{quote}
			\textit{In simple terms, statements are the things you write to tell Python what your programs should do. If, as suggested [omitted], programs ``do things with stuff,'' then statements are the way you specify what sort of things a program does. Less informally, Python is a procedural, statement-based language; by combining statements, you specify a procedure that Python performs to satisfy a program's goals.} 
		\end{quote}
	}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What are Python's statements?}
	\note{Table \ref{tab:python_statements} illustrates common Python statements, their role, and application examples. Some of these statements were used in the examples considered so far. Other statements --- the majority --- will be faced in the next sections of the current chapter and/or in the subsequent chapters.}
\end{paracol}
\clearpage

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Python Statements}
	\label{tab:python_statements}
	\begin{tabular}{lll}
		\toprule \toprule
		Statement & Role & Example \\
		\midrule
		\texttt{import} & Module access & \texttt{import math} \\
		\texttt{from} & Attribute access & \texttt{from math import sqrt} \\
		\texttt{class} & Building ad hoc objects & \texttt{class Subclass(Superclass): def method(self): pass} \\
		\texttt{del} & Deleting references & \texttt{del a} \\
		Assignment & Creating references & \texttt{a = "before b"} \\ 
		Calls and other expressions & Running functions & \texttt{file.write("Hello")}\\
		\texttt{print} & Printing objects & \texttt{print("Hello")} \\ 
		\texttt{if/elif/else} & Selecting actions & \texttt{if "abc" in text: print(text)} \\ 
		\texttt{for/else} & Iteration & \texttt{for x in mylist: print(x)} \\
		\texttt{while/else} & General loops & \texttt{while X > Y: print("Hello")} \\ 
		\texttt{pass} & Empty placeholder & \texttt{while True: pass} \\  
		\texttt{break} &  Loop exit & \texttt{while True: if exit test(): break} \\ 
		\texttt{continue} & Loop continue & \texttt{while True: if skiptest(): continue} \\ 
		\texttt{def} & Functions and methods & \texttt{def f(a, b, c=1, *d): print(a+b+c+d[0])} \\ 
		\texttt{return} & Functions results & \texttt{def f(a, b, c=1, *d): return a+b+c+d[0]} \\ 
		\texttt{yield} & Generator functions & \texttt{def gen(n): for i in n: yield i*2} \\ 
		\bottomrule
	\end{tabular}
\end{sidewaystable}
\clearpage

\section{Control Flow (or If-Then Statements)}

\begin{paracol}{2}
\question{\raggedright What is control flow in Python?}
\note{Many Python statements we write are compound statements: there is one statement nested inside another. The outer statement is called the `if' statement and the inner statement is called the `then' statement. The `if' statement is used to determine whether to execute the `then' statement. Specifically, the `then' statement is executed insofar as the `if' statement evaluates to `True.' Snippet 4.28 illustrates a control flow case, a simple rule-based product recommender that suggests products based on users' purchasing patterns. If product \texttt{x} belongs to a user's set of past purchases, then a certain item is recommended; otherwise, no recommendation is offered (see lines 7 and 8, containing the \texttt{else} statement).} }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.28 --- an example of control flow in Python}
# a set with a customer's past purchases
>>> S = set(["a", "x", "u"])

# a rule-based product recommender 
>>> if "x" in S:
...     print("Customers who bought x also bought Air Jordan 7 Retro Miro")
... else:
...     pass
Customers who bought x also bought Air Jordan 7 Retro Miro
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright End of line $\rightarrow$ end of the statement}
	\note{Any Python statements are contained in the same line --- the end of the line equates to the statement end. In the interest of redundancy, Python statements do not traverse multiple lines. In Snippet 4.28, the if statement is in line 5; the then statement is in line 6.} 
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright The `:' character is required for nested statements!}
	\note{The colon character is required to separate the if statement from the `then' statement (see Snippet 4.28 line 5).}
\end{paracol}	

\begin{paracol}{2}
	\question{\raggedright Indentation has substantive meaning in Python!}
	\note{`Then' statements are indented (with a tab or four consecutive spaces). Do not creatively use indents to embellish your code --- that is not consistent with Python's rules and design principles (see Snippet 4.28 line 6).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright End of indentation $\rightarrow$ end of nested statements}
	\note{`Then' statements are indented (with a tab or four consecutive spaces). In Snippet 4.28, the indentation in line 6 makes lines 5 and 6 to be evaluated together.}
\end{paracol}

\begin{paracol}{2}
\question{\raggedright Multiple `then' statements}
\note{Exmple 4.29 shows how to use \texttt{elif} to concatenate multiple `if-then' statements in the same control flow. Like in Snippet 4.28, the `else' statement defines the residual behavior of the control flow; that is, what Python does when both the `if' and `elif' statements evaluate to `False.'}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.29 --- an example of control flow with multiple `if-then' statements in Python}
# a list with a customer's past purchases
>>> S = set(["a", "w", "u"])

# a rule-based product recommender 
>>> if "x" in S:
...     print("Customers who bought x also bought Air Jordan 7 Retro Miro")
... elif "w" in S:
	print("How about Converse Chuck Taylor All Star?")
... else:
	print("Falling short of suggestions --- I'm a dull recommender!")
How about Converse Chuck Taylor All Star?
\end{pythoncode}

\begin{paracol}{2}
\question{\raggedright Nested if-then statements}
\note{In Python, it is possible to nest an if-then statement into another. In Snippet 4.30, the `if' statements in lines 6 and 8 are nested inside the `if' statement in line 5. It is worth noticing that lines 7 and 9 --- regarding `then' statements --- are indented twice because they terminate distinct if-then statements nested in the broader if-then statement commencing on line 5.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.30 --- an example of nested control flow in Python}
# a list with a customer's past purchases
>>> S = set(["a", "x", "b"])

# a rule-based product recommender 
>>> if "x" in S:
...     if "a" in S:
...         print("Customers who bought x & a also bought Air Force")
...     elif "u" in S:
...         print("Customers who bought x & u also bought Air Max 95")
... else:
...    print("Falling short of suggestions --- I'm a dull recommender!") 
Customers who bought x & a also bought Air Force
\end{pythoncode}

\section{While and For Loops}
\label{sec:while_and_for_loops}

\begin{paracol}{2}
	\question{\raggedright Looping!}
	\note{Oftentimes, we write Python statements that repeat a same task --- i,e., they loop a certain number of times or over multiple items.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we write loops in Python?}
	\note{Using \href{https://docs.python.org/3/reference/compound_stmts.html#for}{\texttt{for}} and \href{https://docs.python.org/3/reference/compound_stmts.html#while}{\texttt{while}} statements.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What is the difference between \texttt{for} and \texttt{while} statements?}
	\note{The \href{https://docs.python.org/3/reference/compound_stmts.html#while}{\texttt{while}} statement provides a way to code general loops. The \href{https://docs.python.org/3/reference/compound_stmts.html#for}{\texttt{for}} statement is designed for stepping through the items in a sequence or other iterable object and running a block of code for each.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.31 --- \texttt{while} loop examples}
# loop until reaching a numeric threshold
>>> i = 0
>>> while i <= 3:
...     print(i)
...     i = i + 1
0
1
2
3

# loop until an empty string is returned
>>> x = "Indiana Jones"
>>> while x != "":
...     print(x)
...     x = x[1:]
... 
Indiana Jones
ndiana Jones
diana Jones
iana Jones
ana Jones
na Jones
a Jones
 Jones
Jones
ones
nes
es
s
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright \texttt{while} loops in action}
	\note{\href{https://docs.python.org/3/reference/compound_stmts.html#while}{\texttt{while}} statements run a code block insforar as a test evaluates to True. In the upper section of Exmple 4.31, we assing a \texttt{i} to a number. Then we create a for loop with the following elements: the first one is a statementing testing wether \texttt{i} is smaller or equal 3 (see line 3); the second element is the loop body (indented), which is repeated as long as the test evaluates to \texttt{True}. It is worth noticing that every iteration of the loop body produces a unitary increase in \texttt{i} --- therefore, the program leaves the loop after four iterations. In the lower section of Snippet 4.31, we assigng the variable \texttt{x} to a string (line 13), which we eventually print (line 14) and  slice (line 15) until we get an empty string (line 13x).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright \texttt{for} loops in action}
	\note{\href{https://docs.python.org/3/reference/compound_stmts.html#for}{\texttt{for}} steps through a sequence of items and carries out a task. In the upper section of Snippet 4.32, we print the result of a mathematical operation that is deployed over the items of a \texttt{list} (an example of Python iterable object). The code included in line 2 assigngs temporarily the variable \texttt{item} to an element of iterable. Then, the code block (indented) is executed over the temporary object. In the lower section of Snippet 4.32, the execution of the loop operates a mathematical expression over the items of a first list and appends the outcome to a second list (line 10).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.32 --- a \texttt{for} loop example}
# print the result of a mathematical operation carried out over a list of items
>>> for item in [0, -99, 13, 6.54]:
...     print(item ** 0.5)  

# run a mathematical operation on a list of items and append the outcome 
# to a second list 
>>> input = [2, 8, 1]
>>> output = []
>>> for item in input:
...    output.append(item + 1)
>>> print(output)
[3, 9, 2]
\end{pythoncode}
\clearpage
	
\begin{paracol}{2}
	\question{\raggedright \texttt{for} loops with dictionaries}
	\note{Like lists, dictionaries are iterable objects. In the upper section of Snippet 4.33, we create a dictionary and iterate over its items printing a simple predicate. As we know from section \ref{sec:dictionaries}, we access a dictionary's values by keys. Hence, in line 5, we retrieve the keys of \texttt{D}. Then, in line 12, we fetch the value of the temporary object \texttt{k}, namely, \texttt{D[k]}. Particularly, we print the temporary object \texttt{k}, the string object \texttt{IS}, and the value associated with \texttt{k}; that is, \texttt{D[k]}. In Snippet 34, we accomplish the same task of Snippet 33. However, the loop regards a dictionary's items --- i.e., key-value pairs --- instead of keys (that is self-evident from the comparison of Snippet 33's line 55 and Snippet 34's line 5). }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.33 --- looping on dictionary keys}
# the dictionary
>>> D = {"Thor": "Asgardian", "Vision": "android", "Wanda Maximoff": "human"}

# get the keys of D
>>> keys = D.keys()
>>> print(keys)
dict_keys(['Thor', 'Vision', 'Wanda Maximoff'])

# iterate over the keys to fetch the dictionary values and do something 
# with them
>>> for k in keys:
...     print(k + " IS " + D[k])
Thor IS Asgardian
Vision IS android
Wanda Maximoff IS human
\end{pythoncode}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.34 --- looping on dictionary items}
# the dictionary
>>> D = {"Thor": "Asgardian", "Vision": "android", "Wanda Maximoff": "human"}

# get the items of D
>>> items = D.items()

# iterate over key-value pairs and do something with them
>>> for k, v in items:
...    print(k + " IS " + v)
Thor IS Asgardian
Vision IS android
Wanda Maximoff IS human
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Counter \texttt{for} loops}
	\note{The built-in class \href{https://docs.python.org/3/library/functions.html#func-range}{\texttt{range}} provides an immutable sequence that is particularly helpful for loops that repeat an action a certain number of times. Snippet 35 shows an example of a for loop with \href{https://docs.python.org/3/library/functions.html#func-range}{\texttt{range}}.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.35 --- a counter loop example}
# show the outcome of range
>>> list(range(3))
[0, 1, 2]

# use range in a for loop
>>> for i in range(3):
...     print(i, ":-)")
0 :-)
1 :-)
2 :-)
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Nested \texttt{for} loops}
    \note{A Python statement that contains multiple \textt{for} loops is a nested \texttt{for} loop. Mainly, a
    \texttt{for} loop allows to carry out a task over the elements of two iterables jointly. The outer loop considers the individual items of the first iterable (see Snippet 4.26, line 6); the inner loop (indented) considers the individual items of the second list (see line 7). Once we have created a pair of temporary objects, we can do something with it (see line 8).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.36 --- a nested loop example}
# the lists
>>> LETTERS = ["x", "y", "z"]
>>> COLORS = ["blue", "green", "red"]

# create all permutations of letters and colors and print them
>>> for i in LETTERS:
...     for j in COLORS:
...         print(i, " - ", j)
x  <->  blue
x  <->  green
x  <->  red
y  <->  blue
y  <->  green
y  <->  red
z  <->  blue
z  <->  green
z  <->  red
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Nested \texttt{for} loops Vs. \texttt{zip} for loops}
	\note{Contrarily to the nested \texttt{for} loops, which considers all permutations containing multiple iterables' items, the built-in \href{https://docs.python.org/3/library/functions.html#zip}{zip} steps through several iterables \emph{in parallel}, producing tuples with an item from each one. As shown in Snippet 4.37, there is neither an inner nor an outer for loop in this case --- instead, there is a single loop considering two temporary objects, \texttt{i} and \texttt{j}, that occupy the same position in the offset of the iterables at hand (see line 6; the first item from the first iterable goes with the first item from the second iterable, the second item from the first iterable goes with the second item from the second iterable, and so on and so forth).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.37 --- looping over two iterables in parallel with \texttt{zip} }
# the lists
>>> LETTERS = ["x", "y", "z"]
>>> COLORS = ["blue", "green", "red"]

# create one-to-one matches of items and do something with them
>>> for i, j in zip(LETTERS, COLORS):
...     print(i, " <-> ", j)
x  <->  blue
y  <->  green
z  <->  red
\end{pythoncode}

\section{Iterations and Comprehensions}
\label{sec:iterations_and_comprhensions}

\begin{paracol}{2}
	\question{\raggedright Over and beyond \texttt{while} and \texttt{for} loops}
	\note{As we know from the previous section, \texttt{while} and \texttt{for} loops can handle most repetitive tasks programs need to perform. However, Python provides further tools to make loops \emph{easier to write/read} and \emph{more efficient}. One of the most prominent tools is \href{https://docs.python.org/3/tutorial/datastructures.html}{\texttt{list comprehension}}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Why do we use \texttt{list comprehensions?}}
	\note{To create a list containing the outcome of an action repeated over an iterable's items (see Snippet 4.38, line 14).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we create \texttt{list comprehensions}?}
	\note{We include a Python statement containing a \texttt{for} clause among brackets (see Snippet 4.38, line 12).}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.38 --- \texttt{for} loop Vs. \textt{list comprehension}}
# the for loop way
# --+ create an empty list
L = []
# --+ create a for loop appending the square of some items
>>> for i in range(3):
...    L.append(i ** 2)
# --+ print the list
>>> print(L)
[0, 1, 4]

# the list comprehension way
>>> L = [i ** 2 for i in range(3)]
>>> print(L)
[0, 1, 4]

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright How do we implement a nested \texttt{for} loop in list comprehensions?}
	\note{As Snippet 4.39 shows, a nested for loop becomes a one-liner in a list comprehension. The first \texttt{for} clause in line 7 would correspond to the outer \texttt{for} loop reported in Snippet 4.36, whereas the second \texttt{for} clause in line 7 would correspond to the inner \texttt{for} loop reported in Snippet 4.36.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.39 --- nested for loop with list comprehensions}
# the lists 
>>> LETTERS = ["x", "y", "z"]
>>> COLORS = ["blue", "green", "red"]

# implementing a nested for loop with a list comprehension
>>> LETTER2COLOR = ["{} <-> {}".format(i, j) for i in LETTERS for j in COLORS]
['x <-> blue',
 'x <-> green',
 'x <-> red',
 'y <-> blue',
 'y <-> green',
 'y <-> red',
 'z <-> blue',
 'z <-> green',
 'z <-> red']
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Can we use the \texttt{zip} generator within a list comprehension?}
	\note{Yes, we can. To do that, the \texttt{for} clause must consider two iterables at once (see Snippet 4.40, line 6).}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.40 ---  looping over two iterables in parallel with \texttt{zip} and list comprehension}
# the lists 
>>> LETTERS = ["x", "y", "z"]
>>> COLORS = ["blue", "green", "red"]

# implementing a nested for loop with a list comprehension
>>> LETTER2COLOR = ["{} <-> {}".format(i, j) for i, j in zip(LETTERS, COLORS)]
['1 <-> blue', '2 <-> green', '3 <-> red']
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright Can we use embed control flow in a list comprehension?}
	\note{Yes, we can. To do that, the \texttt{for} clause must be preceded by an \texttt{if} statement and, at least, an \texttt{else} statement (see for example Snippet 4.40's line 22). }
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 4.41 --- control flow in list comprehensions}
# import the function log from math 
from math import log

# the object to manipulate
>>> L1 = [0, 1, 2]

# the for loop way
# --+ the empty list 
L2 = []
# --+ the for loop appending the log of some items
>>> for i in L1:
...     if i > 0:
...         L2.append(log(i))
...     else:
...         L2.append(log(i + 0.001))
# --+ print the list
>>> print(L2)
[-6.907755278982137, 0.0, 0.6931471805599453]

# the list comprehension way
# --+ the list comprehension is a one-liner!
>>> L2 = [log(i) if i > 0 else log(i + 0.001) for i in L1]
# --+ print the list
>>> print(L2)
[-6.907755278982137, 0.0, 0.6931471805599453]
\end{pythoncode}

\theendnotes

\chapter{Technical \& Scientific Computation with NumPy and SciPy}

\hline

\vspace{1em}

Learning goals:

\begin{itemize}
	\item 
	\item 
\end{itemize}

\hline

\vspace{1em}

\section{Installing NumPy and SciPy}

\begin{paracol}{2}
	\question{\raggedright Do NumPy and SciPy come with the official Python installation file?}
	\note{No, they do not. You need to install them separately using the package manager \texttt{pip}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright I am an Anaconda user: do I need to install NumPy and SciPy separately?}
	\note{No, you do not. NumPy and SciPy are included in `base', the default environment of Anaconda. However, if you create a new environment, you need to install NumPy and SciPy --- as well as all the other modules you need --- with the package manager \texttt{conda}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do I install NumPy and SciPy?}
	\note{The easiest way is using the command line. Anaconda users run \texttt{\$ conda install numpy scipy}, whereas Python official release users run \texttt{\$ pip install numpy scipy}. Having said that, Anaconda users can also install the modules they need from within Anaconda-Navigator.}
\end{paracol}

\section{NumPy \texttt{ndarray}}

\begin{paracol}{2}
	\question{\raggedright What is a NumPy \texttt{ndarray}?}
	\note{Put simply, an \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarray}} is a data container, like dictionaries and lists.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Can \texttt{ndarrays} contain objects of different type?}
	\note{No, they cannot. An \texttt{ndarray} must contain homogenous items; that is, items of the same type.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do we create an \texttt{ndarray}?}
	\note{As shown in Snippet 5.1, we pass an object to \href{https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array}{\texttt{numpy.array}}. If the object we pass is a scalar, a 0-dimensional array containing object is returned (line 5). Passing a list to \href{https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array}{\texttt{numpy.array}} produces a one-dimensional array (line 9); passing a list of lists produces a two-dimensional array (line 13); finally, passing a list of lists of lists produces a three-dimensional array (line 18).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.1 --- creating an \texttt{ndarray}}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np
	
# a 0-D array
>>> np.array(0)
array(0)

# a 1-D array
>>> np.array([1, 2, 3, 4])
array([1, 2, 3, 4])

# a 2-D array
>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

# a 3-D array
>>> np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
array([[[1, 2],
        [3, 4]],

       [[5, 6],
        [7, 8]]])

\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright What are the distinctive features of \texttt{ndarrays}?}
	\note{\texttt{ndarrays} have been designed --- and tuned over time --- with flexibility and efficiency in mind. For example, \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}} allow to carry out computations on arrays with a syntax similar to scalar values. As shown in Snippet 5.2, we can multiply an array by a scalar (line 10) as well as add two vectors (14). That is not possible if we use pure Python code. Multiplying a list by a scalar $N$ replicates the ordered collection of items $N$ times (see line 23). Adding two lists yields concatenation (see line 30). At the same time, \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}} support the analysis of large volumes of data\footnote{The Internet has many blog posts showing the performance of NumPy in linear algebra tasks is comparable to compiled languages, such as C.}.}
\end{paracol}
\clearpage 

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.2 --- NumPy allows to manipulate vectors with an expressive syntax}
# import numpy with the socially accepted alias 'np'
import numpy as np

# generate some random
>>> DATA = np.random.randn(3)
>>> print(DATA)
[-0.44144029 -0.44451097  0.31997294]

# can we multiply a list by a scalar with NumPy? Of course!
>>> print(DATA * 3)
[-4.4144029 , -4.44510974,  3.19972941]

# can we sum two arrays with NumPy? Of course!
>>> print(DATA + DATA) 
[-0.88288058, -0.88902195,  0.63994588]

# let us try to replicate the previous tasks in pure Python?
# --+ get the DATA as a list
>>> DATA = list(DATA)
>>> print(DATA)
[-0.4414402896845323, -0.4445109735283278, 0.31997294069261617]
# --+ is the NumPy syntax of line 10 still valid if we use a list? Nope
>>> print(DATA * 3) 
[
-0.4414402896845323, -0.4445109735283278, 0.31997294069261617,
-0.4414402896845323, -0.4445109735283278, 0.31997294069261617,
-0.4414402896845323, -0.4445109735283278, 0.31997294069261617
]
# --+ is the NumPy syntax of line 14 still valid if we use a list? Nope
>>> print(DATA + DATA) 
[
-0.4414402896845323, -0.4445109735283278, 0.31997294069261617,
-0.4414402896845323, -0.4445109735283278, 0.31997294069261617
]
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright How do I check an \texttt{array}'s number of dimensions?}
	\note{In Snippet 5.3, we saw NumPy infers an \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}}'s number of dimensions from the data. Snippet 5.3 shows how to access \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim}{\texttt{.ndim}}, the \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}}'s attribute concerning the number of dimensions. In the example, \texttt{DATA} has two dimensions (e.g., coordinates).}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do I check an \texttt{array}'s shape?}
	\note{The lower section of Snippet 5.3 shows how to access \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape}{\texttt{.shape}}, the \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}}'s attribute concerning the shape. In the example, each dimension of the \texttt{DATA} has size 2.}
\end{paracol}
\clearpage

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.3 --- an array's number of dimensions and shape}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# the data
>>> DATA = np.array([[1, 2], [3, 4]])
>>> print(DATA)
[[1 2]
 [3 4]]

# get the number of dimensions
>>> DATA.ndim 
2

# get the shape
>>> DATA.shape
(2, 2)
\end{pythoncode}

\begin{paracol}{2}
	\question{\raggedright What are the attributes of an \texttt{array}?}
	\note{Table \ref{tab:array_attributes} illustrates the common use attributes of \href{https://numpy.org/doc/stable/reference/arrays.ndarray.html}{\texttt{ndarrays}}.}
\end{paracol}

\begin{table}[!htbp]
	\centering
	\caption{Common Use Attributes of NumPy \texttt{array}}
	\label{tab:array_attributes}
	\begin{tabular}{ll}
		\toprule \toprule
			Attribute} & Synopsis \\
			\midrule 
                        \texttt{DATA.flags} &
                        Information about the memory layout of the array \\
                        \texttt{DATA.shape} &
                        Tuple of array dimensions\\
                        \texttt{DATA.strides}&
                        Tuple of bytes to step in each dimension when traversing an array\\
                        \texttt{DATA.ndim}&
                        Number of array dimensions\\
                        \texttt{DATA.data}&
                        Python buffer object pointing to the start of the array's data\\
                        \texttt{DATA.size}&
                        Number of elements in the array\\
                        \texttt{DATA.itemsize}&
                        Length of one array element in bytes\\
                        \texttt{DATA.nbytes}&
                        Total bytes consumed by the elements of the array\\
			\texttt{DATA.dtype}&
			Data-type of the array's elements\\
     			\bottomrule \\[-1.8ex]
			\multicolumn{2}{l}{Notes: \texttt{DATA} is a fictionary object used to illustrate the usage of the \texttt{array} attributes.} \\
	\end{tabular}
\end{table}
\clearpage 

\begin{paracol}{2}
	\question{\raggedright I know that a NumPy array must contain homogenous data --- but which object types are allowed?}
	\note{Table \ref{tab:array_data_types} reports the NumPy data types. Python beginners are not supposed to appreciate the distinctive attributes of each type. Instead, they may want to get a clear understanding of the high-level types, namely, floating points, complex, integer, boolean, string, or general Python objects. When it comes to working on sophisticated projects, requiring more control over the storage types, then it is highly suggested to get a thorough knowledge of the types in Table \ref{tab:array_data_types}. It is worth noticing that \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.dtype.html}{\texxttt{dtypes}} are a source of NumPy's flexibility for interacting with data coming from other systems. In most cases, they provide a mapping directly onto an underlying disk or memory representation, which makes it easy to read and write binary streams of data to disk and also to connect to code written in a low-level language like C or Fortran. The numerical \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.dtype.html}{\textttt{dtypes}} are named the same way: a type name, like \texttt{float} or \texttt{int}, followed by a number indicating the number of bits per element. A standard double-precision floating-point value takes up 8 bytes or 64 bits. Thus, this type is known in NumPy as \texttt{float64}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright How do I specify the data type of an \texttt{array}?}
	\note{As Snippet 5.4 shows, \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.dtype.html}{\textttt{dtype}} is an optional argument of \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html}{\texttt{ndarray}}. It is also possible to change \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.dtype.html}{\textttt{dtype}} using the method \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.astype.html}{\texttt{.astype()}}.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.4 --- specifying a nd changing \texttt{dtype}}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# accept the default type
>>> A = np.array([1, 2, 3, 4, 5])

# check the type
>>> A.dtype
dtype('int64')

# specify the type
>>> A = np.array([1, 2, 3, 4, 5], dtype=np.int32)

# check the type
>>> A.dtype
type('int32')

# type change 
>>> S = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
>>> S = S.astype(float)
>>> S.dtype
dtype('float64')

\end{pythoncode}

\clearpage

\begin{sidewaystable}[!htbp]
	\centering
	\caption{NumPy Data Types}
	\label{tab:array_data_types}
	\begin{tabular}{p{7cm}p{4cm}p{10cm}}
		\toprule \toprule
			Type & Type Code & Synopsis \\
			\midrule 
			int8, uint8\dotfill & i1, u1 & Signed and unsigned 8-bit (1 byte) integer types \\ 
			int16, uint16\dotfill & i2, u2 & Signed and unsigned 16-bit integer types \\
			int32, uint32\dotfill & i4, u4 & Signed and unsigned 32-bit integer types \\ 
			int64, uint64\dotfill & i8, u8 & Signed and unsigned 64-bit integer types \\
			float16\dotfill & f2 & Half-precision floating point float32 f4 or f Standard single-precision floating point; compatible with C float\\ 
			float64\dotfill & f8 or d & Standard double-precision floating point; compatible with C double and Python\\ 
			float object\dotfill & float128 f16 or g & Extended-precision floating point \\  
			complex64, complex128, complex256\dotfill & c8, c16, c32 & Complex numbers represented by two 32, 64, or 128 floats, respectively  \\ 
			bool\dotfill & ? & Boolean type storing True and False values \\ 
			object\dotfill & O & Python object type; a value can be any Python object \\ 
			string\_\dotfill & S & Fixed-length ASCII string type (1 byte per character); for example, to create a string dtype with length 10, use 'S10' \\ 
			unicode\_\dotfill & U & Fixed-length Unicode type (number of bytes platform specific); same specification semantics as string\_ (e.g., 'U10')	\\
     			\bottomrule \\
	\end{tabular}
\end{sidewaystable}
\clearpage

\section{Array Creation and Manipulation Methods}

\begin{paracol}{2}
	\question{\raggedright Does NumPy offer recipes for creating arrays?}
	\note{Yes, it does. NumPy has seven families of array-creating routines:
	\begin{itemize}
		\item From shape or value
		\item From existing data
		\item Creating record arrays (\texttt{np.rec})
		\item Numerical ranges
		\item Building matrices
		\item The Matrix class
	\end{itemize}}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright Creating arrays from shape or value}
	\note{This family of routines creates arrays with a certain number of dimensions, shape, values, and attributes. Snippet 5.5. shows how to create:
	\begin{itemize}
		\item an array with a certain shape and a constant scalar (see lines 5 --- \href{https://numpy.org/doc/stable/reference/generated/numpy.zeros.html#numpy.zeros}{\texttt{.zeros}}, 12 --- \href{https://numpy.org/doc/stable/reference/generated/numpy.ones.html#numpy.ones}{\texttt{.ones}}, 19 --- \href{https://numpy.org/doc/stable/reference/generated/numpy.full.html#numpy.full}{\texttt{full}}), and
		\item an array containing an identity matrix (see lines 26 --- \href{https://numpy.org/doc/stable/reference/generated/numpy.eye.html#numpy.eye}{\texttt{.eye}} --- and 33 --- \href{https://numpy.org/doc/stable/reference/generated/numpy.identity.html#numpy.identity}{\texttt{.identity}})
	\end{itemize}} 
\end{paracol}
\clearpage

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for Creating Arrays from Shape or Value}
	\label{tab:array_from_shape_or_value}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{np.empty(shape[, dtype, order, like])} & Return a new array of given shape and type, without initializing entries \\
			\texttt{np.empty\_like(prototype[, dtype, order, subok, \ldots])} & Return a new array with the same shape and type as a given array \\
			\texttt{np.eye(N[, M, k, dtype, order, like])} & Return a 2-D array with ones on the diagonal and zeros elsewhere\\
			\texttt{np.identity(n[, dtype, like])} & Return the identity array \\
			\texttt{np.ones(shape[, dtype, order, like])} & Return a new array of given shape and type, filled with ones \\
			\texttt{np.ones\_like(a[, dtype, order, subok, ...])} & Return an array of ones with the same shape and type as a given array \\
			\texttt{np.zeros(shape[, dtype, order, like])} & Return a new array of given shape and type, filled with zeros \\
			\texttt{np.full(shape, fill\_value[, dtype, order, like])} & Return a new array of given shape and type, filled with fill value \\
			\texttt{full\_like(a, fill\_value[, dtype, order, ...])} & Return a full array with the same shape and type as a given array \\
	     	\bottomrule \\[-1.8ex]
	        \multicolumn{2}{l}{Notes: the statements included in the `Routine' column assume NumPy is loaded with the \texttt{np} alias.} \\
	\end{tabular}
\end{sidewaystable}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.5 --- creating arrays from shape or value}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# create an array with zeros only
>>> np.zeros([4,4])
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

# create an array with ones only
>>> np.ones((4,4))
array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])

# create a full matrix with a given scalar
>>> np.full((4,4), -99)
array([[-99, -99, -99, -99],
       [-99, -99, -99, -99],
       [-99, -99, -99, -99],
       [-99, -99, -99, -99]])

# create an identity array of a given shape with .eye 
>>> np.eye(4, 3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 0., 0.]])

# create an identity array with .identity
>>> np.identity(4)
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])
\end{pythoncode}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Creating arrays from existing data}
	\note{In Snippets 5.1 -- 5.4, we saw how to use \href{https://numpy.org/doc/stable/reference/generated/numpy.array.html#numpy.array}{\texttt{array}} for passing data to a NumPy array. Snippet 5.6 shows further routines to create NumPy arrays from existing data include for example:
	\begin{itemize}
		\item \href{https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html#numpy.fromfunction}{\texttt{.fromfunction}}, creating an array by executing a function over each coordinate (line 8)
		\item \href{https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html#numpy.fromfile}{\texttt{.fromfile}}, creating an array from data in a text or binary file (line 19)
		\item \href{https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html#numpy.loadtxt}{\texttt{.loadtxt}}, loading data from a text file (line 37). The example represents a real-world data set containing both numeric and text information. The first argument we pass \href{https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html#numpy.loadtxt}{\texttt{.loadtxt}} is a file object. To correctly parse the data, we also pass the following discretionary arguments to \href{https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html#numpy.loadtxt}{\texttt{.loadtxt}}: i) \texttt{comments="\#"} indicates that any lines in the file commencing with \texttt{\#} must be considered a comment, not a piece of data; ii) \texttt{delimiter=","} indicates that two items separated by the character \texttt{,} belong to different fields (i.e., `columns' to use a spreadsheet-alike vocabulary); iii) texttt{quotechar='"'} indicates that strings are enclosed between double quotes\footnote{This feature was introduced with NumPy 1.23.}.  
	\end{itemize}
	}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.6 --- creating arrays from existing data}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# get data from a function
# --+ create a function
>>> my_function = lambda x, y: x - 0.5 * y ** 2
# --+ create an array from my\fuction for given coordinates
>>> np.fromfunction(my_function, (3, 3), dtype=float)
array([[ 0. , -0.5, -2. ],
       [ 1. ,  0.5, -1. ],
       [ 2. ,  1.5,  0. ]])

# get data from a binary file
# --+ create an array from a list of numbers
>>> D = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])))
# --+ save the raw data to a binary file
>>> D.tofile("data.bin")
# --+ read the data back 
>>> np.fromfile("data.bin", dtype=int)

# get data from a text file
# --+ create a string with the data and some qualitative comments on them
>>> S = """
# Below are some demographic data about Michael J. Jordan (basketball player)
# from Wikipedia.
# 
# Data labels are:
# 
# NAME, BORN, NBA CHAMPIONSHIPS, AVERAGE POINT PER GAME
"Jordan, Michael Jeffrey","17-02-1963",6,30.1
"""
# --+ write the data to a file 
>>> with open("my_data", "w") as pipe:
...     pipe.write(S)
>>> pipe.close()
# --+ read the data and assign them to a NumPy array
>>> np.loadtxt(
...   open("my_data", "r"),
...       dtype={
...             "names": (
...                      "NAME",
...                      "BORN",
...                      "NBA CHAMPIONSHIPS",
...                      "AVERAGE POINT PER GAME"
...	                   ),
...             "formats": ("S30", "S10", "i1", "f2"),
...             },
...       comments="#",
...       delimiter=",",
...       quotechar='"'
...   )
array((b'Jordan, Michael Jeffrey', b'17-02-1963', 6, 30.1),
       dtype=[('NAME', 'S30'),('BORN', 'S10'),
             ('NBA CHAMPIONSHIPS', 'i1'),
             ('AVERAGE POINT PER GAME', '<f2')]
)
\end{pythoncode}

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for Creating Arrays from Existing Data}
	\label{tab:array_from_existing_data}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{np.array(object[,dtype, copy, subok, \ldots])}
			& Create an array \\
			\texttt{np.asarray(a[, dtype, order, like])} 
			& Convert the input to an array \\ 
			\texttt{np.asanyarray(a[, dtype, order, like])} 
			&  Convert the input to an ndarray, but pass ndarray subclasses through \\
                        \texttt{np.ascontiguousarray(a[, dtype, like])}
			& Return a contiguous array (ndim >= 1) in memory (C order)\\
                        \texttt{np.asmatrix(data[, dtype])}
                        & Interpret the input as a matrix\\
                        \texttt{np.copy(a[, order, subok])}
                        & Return an array copy of the given object\\
                        \texttt{np.frombuffer(buffer[, dtype, count, offset, like])}
                        & Interpret a buffer as a 1-dimensional array\\
                        %\texttt{from_dlpack(x, \/)}
                        %& Create a NumPy array from an object implementing the \_\_dlpack\_\_ protocol\\
                        \texttt{np.fromfile(file[, dtype, count, sep, offset, like])}
                        & Construct an array from data in a text or binary file\\
                        \texttt{np.fromfunction(function, shape, *[, dtype, like])}
                        & Construct an array by executing a function over each coordinate\\
                        \texttt{np.fromiter(iter, dtype[, count, like])}
                        & Create a new 1-dimensional array from an iterable object\\
                        \texttt{np.fromstring(string[, dtype, count, like])}
                        & A new 1-D array initialized from text data in a string\\
                        \texttt{np.loadtxt(fname[, dtype, comments, delimiter, ...])}
                        & Load data from a text file\\
	     				\bottomrule \\[-1.8ex]
						\multicolumn{2}{l}{Notes: the statements included in the `Routine' column assume NumPy is loaded with the \texttt{np} alias.} \\
	\end{tabular}
\end{sidewaystable}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Record arrays}
	\note{NumPy arrays do no contain any information about the attributes of the data. For example, a NumPy array cannot accommodate any meta-data, such as the names of the fields included in the data. Here is where \href{https://numpy.org/doc/stable/reference/routines.array-creation.html}{\texttt{.rec}} kick in (see Table \ref{tab:array_for_record_arrays}). For example, \href{https://numpy.org/doc/stable/reference/generated/numpy.core.records.array.html#numpy.core.records.array}{.core.records.array} allows to flexibly specify a field's type and name (see Snippet 5.7, line 8). Once a `recarray' is created, it is possible to fetch its data by field name (see Snippet 5.7, line 11).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.7 --- creating record arrays}
# import records array with an alias that does not conflict with
# `standard' NumPy arrays
>>> from numpy.core.records import array as recarray

# the data
>>> LOCS = [("51.5072° N", "0.1276° W"), ("35.6762° N", "139.6503° E")]

# create a recarray
>>> D = recarray(LOCS, formats=["U12", "U12"], names=["Latitude", "Longitude"])

# fetch the data by field name
>>> D.Latitude
array(['51.5072° N', '35.6762° N'], dtype='<U12')
\end{pythoncode}

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for Creating Record Arrays}
	\label{tab:array_for_record_arrays}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{np.core.records.array(obj[, dtype, shape, ...])} &
			Construct a record array from a wide-variety of objects\\
			\texttt{np.core.records.fromarrays(arrayList[, dtype, ...])} &
			Create a record array from a (flat) list of arrays\\
			\texttt{np.core.records.fromrecords(recList[, dtype, ...])} &
			Create a recarray from a list of records in text form\\
			\texttt{np.core.records.fromstring(datastring[, dtype, ...])} &
			Create a record array from binary data\\
			\texttt{np.core.records.fromfile(fd[, dtype, shape, ...])} &
			Create an array from binary file data\\
			\bottomrule \\[-1.8ex]
		    \multicolumn{2}{l}{Notes: the statements included in the `Routine' column assume NumPy is loaded with the \texttt{np} alias.} \\
	\end{tabular}
\end{sidewaystable}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Creating numerical ranges}
	\note{One may want to create a numerical range for different reasons, including running functional analysis or computer simulation. NumPy has a bunch of array-creating routines for numerical ranges (see Table \ref{tab:array_from_numerical_ranges}), some of which that are quite popular in the fields of technical and scientific computation as well as data science. For example, \href{https://numpy.org/doc/stable/reference/generated/numpy.arange.html#numpy.arange}{\texttt{np.arange}} and \href{https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace}{\texttt{np.linspace}} frequently appear in Python programs when it comes to create evenly spaced values in a certain interval and evely spaced samples respectively (see Snippet 5.8, lines XX and XX). Another popular routine is \href{https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html#numpy.meshgrid}{\texttt{.meshgrid}}, returning coordinate matrices from coordinate vectors.}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.8 --- creating numerical ranges}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# two ranges of evenly spaced values
# --+ evenly spaced values between 0 and 10
>>> np.arange(0, 10, 1)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# --+ ... equivalent to
>>> np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# --+ evenly spaced values between 0 and 10 divided by a 2-unit step
>>> np.arange(0, 10, 2)
array([0, 2, 4, 6, 8])

# 50 evenly spaced values between 0 and 1
>>> np.linspace(0, 1, 10)
array([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
       0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])

# get coordinate matrices from coordinate vectors 
# --+ the 'x-' and 'y-axis' vectors
>>> X = np.linspace(0, 1, 10)
>>> Y = np.linspace(0, 1, 5)
# --+ get 'x-axis' ('y-axis') coordinates for any value of vector Y (X)
>>> XX, YY = np.meshgrid(X, Y)
>>> XX 
array([[0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ],
       [0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ],
       [0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ],
       [0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ],
       [0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ]])
>>> YY 
array([[0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
       [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25],
       [0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 , 0.5 ],
       [0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75],
       [1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  , 1.  ]])
# --+ create a matrix from X and Y 
>>> ZZ = np.sqrt(XX**2 + YY**2)
# --+ check the dimensions of the newly created objects 
>>> print(XX.shape, YY.shape, ZZ.shape)
>>> ((101, 101), (101, 101), (101, 101))
# --+ make a contour plot showing the associations among X, Y, and Z 
# (see Figure 5.1)
>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax = plt.contourf(X, Y, ZZ)
>>> plt.axis('scaled')
>>> plt.colorbar()
>>> plt.show()
\end{pythoncode}

\begin{figure}[!htbp]
\input{contour.pgf}
\caption{A contour plot showing the associations among X, Y, and Z. Notes: the data behind this plot come from Snippet 5.8, lines 22 - 44.}
\label{fig:contour_plot}
\end{figure}

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for Numerical Ranges}
	\label{tab:array_from_numerical_ranges}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{np.arange([start,] stop[, step,][, dtype, like])}&
			Return evenly spaced values within a given interval\\
			\texttt{np.linspace(start, stop[, num, endpoint, ...])}&
			Return evenly spaced numbers over a specified interval\\
			\texttt{np.logspace(start, stop[, num, endpoint, base, ...])}&
			Return numbers spaced evenly on a log scale\\
			\texttt{np.geomspace(start, stop[, num, endpoint, ...])}&
			Return numbers spaced evenly on a log scale (a geometric progression)\\
			\texttt{np.meshgrid(*xi[, copy, sparse, indexing])}&
			Return coordinate matrices from coordinate vectors\\
			\texttt{np.mgrid}&
			\texttt{nd\_grid} instance which returns a dense multi-dimensional ``meshgrid''\\
			\texttt{np.ogrid}&
			\texttt{nd\_grid} instance which returns an open multi-dimensional ``meshgrid''\\
			\bottomrule \\[-1.8ex]
			\multicolumn{2}{l}{Notes: the statements included in the `Routine' column assume NumPy is loaded with the \texttt{np} alias.} \\
	\end{tabular}
\end{sidewaystable}
\clearpage

\begin{paracol}{2}
	\question{\raggedright Building matrices}
	\note{NumPy has routines to create arrays from an existing matrix as well as build matrices with certain properties (see Table \ref{tab:array_for_building_matrices}) As Snippet 5.9 shows, \href{https://numpy.org/doc/stable/reference/generated/numpy.diag.html#numpy.diag}{\texttt{.diag}} creates an array by fetching a matrix's diagonal (see line 10), while \href{https://numpy.org/doc/stable/reference/generated/numpy.tri.html#numpy.tri}{\texttt{.tri}} creates a triangular matrix (see line 17).}
\end{paracol}

\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.9 --- creating arrays from existing data}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

# create an array by fetching a matrix diagonal 
# --+ the matrix 
>>> M = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> M.shape
(3, 3)
# --+ the new array 
>>> A = np.diag(M)
>>> print(A)
[1 5 9]
>>> A.shape
(3,)

# create a triangular matrix
>>> np.tri(10, 10)
array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [1., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
       [1., 1., 1., 0., 0., 0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 0., 0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1., 0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1., 1., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1., 1., 1., 0., 0., 0.],
       [1., 1., 1., 1., 1., 1., 1., 1., 0., 0.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 0.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
\end{pythoncode}

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for Building Matrices}
	\label{tab:array_for_building_matrices}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{np.diag(v[, k])}
			&Extract a diagonal or construct a diagonal array \\
			\texttt{np.diagflat(v[, k])}
			&Create a two-dimensional array with the flattened input as a diagonal\\
		        \texttt{np.tri(N[, M, k, dtype, like])}
			&An array with ones at and below the given diagonal and zeros elsewhere\\
			\texttt{np.tril(m[, k])}
			&Lower triangle of an array\\
			\texttt{np.triu(m[, k])}
			&Upper triangle of an array\\
			\texttt{np.vander(x[, N, increasing])}
			&Generate a Vandermonde matrix\\
			\bottomrule \\[-1.8ex]
			\multicolumn{2}{l}{Notes: the statements included in the `Routine' column assume NumPy is loaded with the \texttt{np} alias.} \\
	\end{tabular}
\end{sidewaystable}
\clearpage

\begin{paracol}{2}
	\question{\raggedright The Matrix Class}
	\note{In Snippet 5.9, line 17, I claim to create a matrix. Actually, the outcome displayed in line 18 is consistent with the concept of `matrix' we have been taught in a typical linear algebra class: what a human being sees is a set of numbers arranged in rows and columns. However, in NumPy terms, the object displayed in line 18 is an array with two dimensions. If we want to create a NumPy Matrix Class object, we have to call \href{https://numpy.org/doc/stable/reference/generated/numpy.matrix.html#numpy.matrix}{\texttt{np.matrix}}, a subclass of \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray}{\texttt{np.ndarray}}. Table \ref{tab:matrix_class} illustrates the two matrix-creating routines of NumPy.}
\end{paracol}

\begin{paracol}{2}
	\question{What is the advantage of using a matrix class object?}
	\note{As we will see later on in this chapter, the advantage of using a matrix class object is that we can use the matrix class object to perform matrix operations with a simple and intuitive syntax. For example, we can use the matrix class object to perform matrix multiplication, matrix addition, and matrix subtraction.}
\end{paracol}


\begin{pythoncode}[linenos=true,]{colback=base_c!5, colframe=base_c, title=\sffamily Snippet 5.6 --- creating arrays from existing data}
# import numpy with the socially accepted alias 'np'
>>> import numpy as np

\end{pythoncode}

\begin{sidewaystable}[!htbp]
	\centering
	\caption{Routines for the Matrix Class}
	\label{tab:array_for_matrix_class}
	\begin{tabular}{lp{12cm}}
		\toprule \toprule
			Routine & Synopsis \\
			\midrule
			\texttt{} & \\
		\bottomrule 
	\end{tabular}
\end{sidewaystable}

\clearpage
\section{Universal Functions in NumPy}

\begin{paracol}{2}
	\question{\rggedright What is a universal function?}
	\note{A universal function, or \href{https://numpy.org/doc/stable/reference/ufuncs.html}{\texttt{ufunc}}, is a function that performs element-wise operations on \texttt{ndarrays}. You can think of them as fast vectorized wrappers for simple functions that take one or more scalar values and produce one or more scalar results\footnote{Here is an interesting passage from the official \href{https://numpy.org/doc/stable/glossary.html#term-vectorization}{NumPy} documentation: \textit{NumPy hands off array processing to C, where looping and computation are much faster than in Python. To exploit this, programmers using NumPy eliminate Python loops in favor of array-to-array operations. vectorization can refer both to the C offloading and to structuring NumPy code to leverage it.}}.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What is the rationale for using \texttt{ufuncts}?}
	\note{Per the previous point, using a \href{https://numpy.org/doc/stable/reference/ufuncs.html}{\texttt{ufunc}} offer substantial performance advantages \textit{vis a' vis} non-vectorized code --- i.e., code using built-in Python iterators.}
\end{paracol}

\begin{paracol}{2}
	\question{\raggedright What are the \texttt{unfunct} options available in NumPy?}
	\note{There are circa sixty universal functions implemented in NumPy. For the sake of convenience, the full list of \href{https://numpy.org/doc/stable/reference/ufuncs.html}{\texttt{ufunc}} options is reported in Tables \ref{tab:numpy_math_ufuncs} - \ref{tab:numpy_comparison_ufuncs}. The following sections of the current chapter will illustrate how to use some of the popular central \texttt{ufuncts} in NumPy.}
\end{paracol}

\section{Mathematical Methods}




\section{Statistical Methods}



\section{Linear Algebra}



\section{Pseudorandom Number Generation}



\section{File Input and Output with \texttt{ndarrays}}



\section{}

\theendnotes

\chapter{Data Management with Pandas}

\ldots

\chapter{Coda}
\ldots

\clearpage

\begin{appendices}
\appendixpage
\noappendicestocpagenum
\addappheadtotoc

\chapter{Cheat Sheets}

\begin{table}[!htbp]
\centering
\caption{Helpful Escapes}
\label{tab:helpful_escapes}
	\begin{tabular}{cl}
		\toprule \toprule
		Escape & Meaning \\
		\midrule
		\texttt{$\setminus\setminus$} & Backslash (stores one $\setminus$) \\
		\texttt{$\setminus$'} & Single quotes escape (stores \texttt{'})\\
		\texttt{$\setminus$"} & Double quotes escape (stores \texttt{"})\\
		\texttt{$\setminus$a} & Bell \\
		\texttt{$\setminus$b} & Backspace \\
		\texttt{$\setminus$f} & Formfeed \\
		\texttt{$\setminus$n} & Newline \\
		\texttt{$\setminus$r} & Carriage return \\
		\texttt{$\setminus$t} & Horizontal tab \\
		\texttt{$\setminus$v} & Vertical tab \\
		\bottomrule
	\end{tabular}
\end{table}

\begin{table}[!htbp]
\centering
\caption{Comprehensive List of String Methods}
\label{tab:string_methods}
\begin{tabular}{lp{12cm}}
\toprule \toprule
\textbf{Cases I}          &                                                                                                                                               \\ \midrule
s.capitalize()           & Capitalize s \# 'hello' =\textgreater 'Hello'                                                                                                   \\
s.lower()                & Lowercase s \# 'HELLO' =\textgreater 'hello'                                                                                                    \\
s.swapcase()             & Swap cases of all characters in s \# 'Hello' =\textgreater "hELLO"                                                                              \\
s.title()                & Titlecase s \# 'hello world' =\textgreater 'Hello World'                                                                                        \\
s.upper()                & Uppercase s \# 'hello' =\textgreater 'HELLO'                                                                                                    \\ \midrule
\textbf{Sequence Operations I}    &                                                                                                                                                 \\ \midrule
s2 in s                  & Return true if s contains s2                                                                                                                    \\
s + s2                   & Concat s and s2                                                                                                                                 \\
len(s)                   & Length of s                                                                                                                                     \\
min(s)                   & Smallest character of s                                                                                                                         \\
max(s)                   & Largest character of s                                                                                                                          \\ \midrule 
\textbf{Sequence Operations II}   &                                                                                                                                                 \\ \midrule
s2 not in s              & Return true if s does not contain s2                                                                                                            \\
s * integer              & Return integer copies of s concatenated \# 'hello' =\textgreater 'hellohellohello'                                                              \\
s{[}index{]}             & Character at index of s                                                                                                                         \\
s{[}i:j:k{]}             & Slice of s from i to j with step k                                                                                                              \\
s.count(s2)              & Count of s2 in s                                                                                                                                \\ \midrule
\textbf{Whitespace I}             &                                                                                                                                                 \\ \midrule
s.center(width)          & Center s with blank padding of width \# 'hi' =\textgreater ' hi '                                                                               \\
s.isspace()              & Return true if s only contains whitespace characters                                                                                            \\
s.ljust(width)           & Left justifiy s with total size of width \# 'hello' =\textgreater 'hello '                                                                      \\
s.rjust(width)           & Right justify s with total size of width \# 'hello' =\textgreater ' hello'                                                                      \\
s.strip()                & Remove leading and trailing whitespace from s \# ' hello ' =\textgreater 'hello'                                                                \\ \midrule
\textbf{Find / Replace I}         &                                                                                                                                                 \\ \midrule
s.index(s2, i, j)        & Index of first occurrence of s2 in s after index i and before index j                                                                           \\
s.find(s2)               & Find and return lowest index of s2 in s                                                                                                         \\
s.index(s2)              & Return lowest index of s2 in s (but raise ValueError if not found)                                                                              \\
s.replace(s2, s3)        & Replace s2 with s3 in s                                                                                                                         \\
s.replace(s2, s3, count) & Replace s2 with s3 in s at most count times                                                                                                     \\
s.rfind(s2)              & Return highest index of s2 in s                                                                                                                 \\
s.rindex(s2)             & Return highest index of s2 in s (raise ValueError if not found)                                                                                 \\ \midrule
\textbf{Cases II}                 &                                                                                                                                                 \\ \midrule
s.casefold()             & Casefold s (aggressive lowercasing for caseless matching) \# 'ßorat' =\textgreater 'ssorat'                                                     \\
s.islower()              & Return true if s is lowercase                                                                                                                   \\
s.istitle()              & Return true if s is titlecased \# 'Hello World' =\textgreater true                                                                              \\
s.isupper()              & Return true if s is uppercase                                                                                                                   \\ \midrule
\textbf{Inspection I}             &                                                                                                                                                 \\ \midrule
s.endswith(s2)           & Return true if s ends with s2                                                                                                                   \\
s.isalnum()              & Return true if s is alphanumeric                                                                                                                \\
s.isalpha()              & Return true if s is alphabetic                                                                                                                  \\
s.isdecimal()            & Return true if s is decimal                                                                                                                     \\
s.isnumeric()            & Return true if s is numeric                                                                                                                     \\
s.startswith(s2)         & Return true is s starts with s2                                                                                                                 \\                                                   
\end{tabular}
\end{table}

\begin{table}[!htbp]
\centering
\caption*{\textsc{Table A.2} \\ (Cont'ed)}
\label{tab:string_methods_cted}
\begin{tabular}{lp{12cm}}
\\ \midrule
\textbf{Splitting I}              &                                                                                                                                                 \\ \midrule
s.join('123')            & Return s joined by iterable '123' \# 'hello' =\textgreater '1hello2hello3'                                                                      \\
s.partition(sep)         & Partition string at sep and return 3-tuple with part before, the sep itself, and part after \# 'hello' =\textgreater ('he', 'l', 'lo')          \\
s.rpartition(sep)        & Partition string at last occurrence of sep, return 3-tuple with part before, the sep, and part after \# 'hello' =\textgreater ('hel', 'l', 'o') \\
s.rsplit(sep, maxsplit)  & Return list of s split by sep with rightmost maxsplits performed                                                                                \\
s.split(sep, maxsplit)   & Return list of s split by sep with leftmost maxsplits performed                                                                                 \\
s.splitlines()           & Return a list of lines in s \# 'hello\textbackslash{}nworld' =\textgreater {[}'hello', 'world'{]}                                               \\ \midrule
\textbf{Inspection II}            &                                                                                                                                                 \\ \midrule
s{[}i:j{]}               & Slice of s from i to j                                                                                                                          \\
s.endswith((s1, s2, s3)) & Return true if s ends with any of string tuple s1, s2, and s3                                                                                   \\
s.isdigit()              & Return true if s is digit                                                                                                                       \\
s.isidentifier()         & Return true if s is a valid identifier                                                                                                          \\
s.isprintable()          & Return true is s is printable                                                                                                                   \\ \midrule
\textbf{Whitespace II}            &                                                                                                                                                 \\ \midrule
s.center(width, pad)     & Center s with padding pad of width \# 'hi' =\textgreater 'padpadhipadpad'                                                                       \\
s.expandtabs(integer)    & Replace all tabs with spaces of tabsize integer \# 'hello\textbackslash{}tworld' =\textgreater 'hello world'                                    \\
s.lstrip()               & Remove leading whitespace from s \# ' hello ' =\textgreater 'hello '                                                                            \\
s.rstrip()               & Remove trailing whitespace from s \# ' hello ' =\textgreater ' hello'                                                                           \\
s.zfill(width)           & Left fill s with ASCII '0' digits with total length width \# '42' =\textgreater '00042'  
   \\                                                      
\bottomrule
\end{tabular}
\end{table}
\clearpage

\begin{table}
\caption{NumPy Universal Functions: Mathematical Operations}
\label{tab:numpy_math_ufuncs}
\centering
\begin{tabular}{lp{8.5cm}}
\toprule \toprule 
Universal Function & Synopsis \\
\midrule
add(x1, x2, /[, out, where, casting, order, ...])
& Add arguments element-wise\\
subtract(x1, x2, /[, out, where, casting, ...])
& Subtract arguments, element-wise\\
multiply(x1, x2, /[, out, where, casting, ...])
& Multiply arguments element-wise\\
matmul(x1, x2, /[, out, casting, order, ...])
& Matrix product of two arrays\\
divide(x1, x2, /[, out, where, casting, ...])
& Divide arguments element-wise\\
logaddexp(x1, x2, /[, out, where, casting, ...])
& Logarithm of the sum of exponentiations of the inputs\\
logaddexp2(x1, x2, /[, out, where, casting, ...])
& Logarithm of the sum of exponentiations of the inputs in base-2\\
true_divide(x1, x2, /[, out, where, ...])
& Divide arguments element-wise\\
floor_divide(x1, x2, /[, out, where, ...])
& Return the largest integer smaller or equal to the division of the inputs\\
negative(x, /[, out, where, casting, order, ...])
& Numerical negative, element-wise\\
positive(x, /[, out, where, casting, order, ...])
& Numerical positive, element-wise\\
power(x1, x2, /[, out, where, casting, ...])
& First array elements raised to powers from second array, element-wise\\
float_power(x1, x2, /[, out, where, ...])
& First array elements raised to powers from second array, element-wise\\
remainder(x1, x2, /[, out, where, casting, ...])
& Returns the element-wise remainder of division\\
mod(x1, x2, /[, out, where, casting, order, ...])
& Returns the element-wise remainder of division\\
fmod(x1, x2, /[, out, where, casting, ...])
& Returns the element-wise remainder of division\\
divmod(x1, x2[, out1, out2], / [[, out, ...])
& Return element-wise quotient and remainder simultaneously\\
absolute(x, /[, out, where, casting, order, ...])
& Calculate the absolute value element-wise\\
fabs(x, /[, out, where, casting, order, ...])
& Compute the absolute values element-wise\\
rint(x, /[, out, where, casting, order, ...])
& Round elements of the array to the nearest integer\\
sign(x, /[, out, where, casting, order, ...])
& Returns an element-wise indication of the sign of a number\\
heaviside(x1, x2, /[, out, where, casting, ...])
& Compute the Heaviside step function\\
conj(x, /[, out, where, casting, order, ...])
& Return the complex conjugate, element-wise\\
conjugate(x, /[, out, where, casting, ...])
& Return the complex conjugate, element-wise\\
exp(x, /[, out, where, casting, order, ...])
& Calculate the exponential of all elements in the input array\\
exp2(x, /[, out, where, casting, order, ...])
& Calculate 2**p for all p in the input array\\
log(x, /[, out, where, casting, order, ...])
& Natural logarithm, element-wise\\
log2(x, /[, out, where, casting, order, ...])
& Base-2 logarithm of x\\
log10(x, /[, out, where, casting, order, ...])
& Return the base 10 logarithm of the input array, element-wise\\
expm1(x, /[, out, where, casting, order, ...])
& Calculate exp(x) - 1 for all elements in the array\\
log1p(x, /[, out, where, casting, order, ...])
& Return the natural logarithm of one plus the input array, element-wise\\
sqrt(x, /[, out, where, casting, order, ...])
& Return the non-negative square-root of an array, element-wise\\
square(x, /[, out, where, casting, order, ...])
& Return the element-wise square of the input\\
cbrt(x, /[, out, where, casting, order, ...])
& Return the cube-root of an array, element-wise\\
reciprocal(x, /[, out, where, casting, ...])
& Return the reciprocal of the argument, element-wise\\
gcd(x1, x2, /[, out, where, casting, order, ...])
& Returns the greatest common divisor of \|x1\| and \|x2\| \\ 
lcm(x1, x2, /[, out, where, casting, order, ...])
& Returns the lowest common multiple of \|x1\| and \|x2\| \\
\bottomrule
\end{tabular}
\end{table}
\clearpage

\begin{table}
\caption{NumPy Universal Functions: Trigonometric Operations}
\centering
\begin{tabular}{lp{8.5cm}}
\toprule \toprule 
Universal Function & Synopsis \\
\midrule
sin(x, /[, out, where, casting, order, ...])
& Trigonometric sine, element-wise\\
cos(x, /[, out, where, casting, order, ...])
& Cosine element-wise\\
tan(x, /[, out, where, casting, order, ...])
& Compute tangent element-wise\\
arcsin(x, /[, out, where, casting, order, ...])
& Inverse sine, element-wise\\
arccos(x, /[, out, where, casting, order, ...])
& Trigonometric inverse cosine, element-wise\\
arctan(x, /[, out, where, casting, order, ...])
& Trigonometric inverse tangent, element-wise\\
arctan2(x1, x2, /[, out, where, casting, ...])
& Element-wise arc tangent of x1/x2 choosing the quadrant correctly\\
hypot(x1, x2, /[, out, where, casting, ...])
& Given the "legs" of a right triangle, return its hypotenuse\\
sinh(x, /[, out, where, casting, order, ...])
& Hyperbolic sine, element-wise\\
cosh(x, /[, out, where, casting, order, ...])
& Hyperbolic cosine, element-wise\\
tanh(x, /[, out, where, casting, order, ...])
& Compute hyperbolic tangent element-wise\\
arcsinh(x, /[, out, where, casting, order, ...])
& Inverse hyperbolic sine element-wise\\
arccosh(x, /[, out, where, casting, order, ...])
& Inverse hyperbolic cosine, element-wise\\
arctanh(x, /[, out, where, casting, order, ...])
& Inverse hyperbolic tangent element-wise\\
degrees(x, /[, out, where, casting, order, ...])
& Convert angles from radians to degrees\\
radians(x, /[, out, where, casting, order, ...])
& Convert angles from degrees to radians\\
deg2rad(x, /[, out, where, casting, order, ...])
& Convert angles from degrees to radians\\
rad2deg(x, /[, out, where, casting, order, ...])
& Convert angles from radians to degrees\\
\bottomrule
\end{tabular}
\end{table}
\clearpage

\begin{table}
\caption{NumPy Universal Functions: Floating Operations}
\centering
\begin{tabular}{lp{8.5cm}}
\toprule \toprule 
Universal Function & Synopsis \\
\midrule
isfinite(x, /[, out, where, casting, order, ...])
& Test element-wise for finiteness (not infinity and not Not a Number)\\
isinf(x, /[, out, where, casting, order, ...])
&  Test element-wise for positive or negative infinity\\
isnan(x, /[, out, where, casting, order, ...])
& Test element-wise for NaN and return result as a boolean array\\
isnat(x, /[, out, where, casting, order, ...])
& Test element-wise for NaT (not a time) and return result as a boolean array\\
fabs(x, /[, out, where, casting, order, ...])
& Compute the absolute values element-wise\\
signbit(x, /[, out, where, casting, order, ...])
& Returns element-wise True where signbit is set (less than zero)\\
copysign(x1, x2, /[, out, where, casting, ...])
& Change the sign of x1 to that of x2, element-wise\\
nextafter(x1, x2, /[, out, where, casting, ...])
& Return the next floating-point value after x1 towards x2, element-wise\\
spacing(x, /[, out, where, casting, order, ...])
& Return the distance between x and the nearest adjacent number\\
modf(x[, out1, out2], / [[, out, where, ...])
& Return the fractional and integral parts of an array, element-wise\\
ldexp(x1, x2, /[, out, where, casting, ...])
& Returns x1 * 2**x2, element-wise\\
frexp(x[, out1, out2], / [[, out, where, ...])
& Decompose the elements of x into mantissa and twos exponent\\
fmod(x1, x2, /[, out, where, casting, ...])
& Returns the element-wise remainder of division\\
floor(x, /[, out, where, casting, order, ...])
& Return the floor of the input, element-wise\\
ceil(x, /[, out, where, casting, order, ...])
& Return the ceiling of the input, element-wise\\
trunc(x, /[, out, where, casting, order, ...])
& Return the truncated value of the input, element-wise\\
\bottomrule
\end{tabular}
\end{table}
\clearpage

\begin{table}
\caption{NumPy Universal Functions: Comparison Operations}
\label{tab:numpy_comparison_ufuncs}
\centering
\begin{tabular}{lp{8.5cm}}
\toprule \toprule 
Universal Function & Synopsis \\ \midrule
greater(x1, x2, /[, out, where, casting, ...])
& Return the truth value of (x1 > x2) element-wise\\
greater_equal(x1, x2, /[, out, where, ...])
& Return the truth value of (x1 >= x2) element-wise\\
less(x1, x2, /[, out, where, casting, ...])
& Return the truth value of (x1 < x2) element-wise\\
less_equal(x1, x2, /[, out, where, casting, ...])
& Return the truth value of (x1 <= x2) element-wise\\
not_equal(x1, x2, /[, out, where, casting, ...])
& Return (x1 != x2) element-wise\\
equal(x1, x2, /[, out, where, casting, ...])
& Return (x1 == x2) element-wise\\
logical_and(x1, x2, /[, out, where, ...])
& Compute the truth value of x1 AND x2 element-wise\\
logical_or(x1, x2, /[, out, where, casting, ...])
& Compute the truth value of x1 OR x2 element-wise\\
logical_xor(x1, x2, /[, out, where, ...])
& Compute the truth value of x1 XOR x2, element-wise\\
logical_not(x, /[, out, where, casting, ...])
& Compute the truth value of NOT x element-wise\\
maximum(x1, x2, /[, out, where, casting, ...])
& Element-wise maximum of array elements\\
minimum(x1, x2, /[, out, where, casting, ...])
& Element-wise minimum of array elements\\
fmax(x1, x2, /[, out, where, casting, ...])
& Element-wise maximum of array elements\\
fmin(x1, x2, /[, out, where, casting, ...])
& Element-wise minimum of array elements\\
\midrule
\bottomrule
\end{tabular}
\end{table}
\clearpage

\chapter{Collaborative and Versioning Tools}

...

\end{appendices}


% ================================= Snippets ==============================
%
%\vspace*{3ex} % breaks the red line
%
%\begin{paracol}{2}  
%    \question{Here's another question.}
%    \note{\lipsum[4]}
%    \note{\lipsum[2]}   
%\end{paracol}
%
%\summary[\clearpage]{This is a longer box that will will close the question and {\Large \bfseries start a new page.} \lipsum[2]}
%
%\section{Second topic}
%
%\begin{paracol}{2}
%    \question{Here's another question to begin the new page.}   
%    \note{\lipsum[3]}
%    \note{\lipsum[4]}
%\end{paracol}
%        
%\summary{And another summary that will close the question and {\Large 
%\bfseries stay in the same page.}}
%
%\section{Another topic, several questions}
%
%\begin{paracol}{2}
%    \question{This is  question I.}     
%    \note{I The first piece of evidence is mandatory.}
%    \note{Now add up to five \ldots}%
%    \note{\ldots\ additional pieces of evidence.}
%\end{paracol}
%\vspace*{3ex} % breaks the red line
%    
%\begin{paracol}{2}
%    \question{Here's  question II.} 
%    \note{II The first piece of evidence is mandatory.}
%    \note{Now add up to five \ldots}%
%    \note{\ldots\ additional pieces of evidence.}
%\end{paracol}
%
%\clearpage% breaks the red line
%\begin{paracol}{2}
%    \question{And question III.}
%    
%    \note{III The first piece of evidence is mandatory.}
%    \note{Now add up to five\ldots}%
%    \note{\ldots\ additional pieces of evidence.}
%    \note{\ldots\ and more \ldots}
%    \note{\ldots\ and more.}
%\end{paracol}
%
%\summary{And another summary that will close the question and {\Large \bfseries stay in the same page.}}        
%
%\lipsum[1]
    
\end{document}
